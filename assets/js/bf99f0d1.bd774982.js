"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[79],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=c(n),m=a,f=p["".concat(l,".").concat(m)]||p[m]||d[m]||s;return n?r.createElement(f,i(i({ref:t},u),{},{components:n})):r.createElement(f,i({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=m;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:a,i[1]=o;for(var c=2;c<s;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},9992:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>i,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const s={id:"closures",title:"Closure Functions in Rust",sidebar_label:"Closures",description:"Learn how to use function closures."},i=void 0,o={unversionedId:"Rust/section7/closures",id:"Rust/section7/closures",isDocsHomePage:!1,title:"Closure Functions in Rust",description:"Learn how to use function closures.",source:"@site/docs/Rust/section7/closures.md",sourceDirName:"Rust/section7",slug:"/Rust/section7/closures",permalink:"/docs/Rust/section7/closures",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section7/closures.md",version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1680626061,formattedLastUpdatedAt:"4/4/2023",frontMatter:{id:"closures",title:"Closure Functions in Rust",sidebar_label:"Closures",description:"Learn how to use function closures."},sidebar:"rust",previous:{title:"Iterators",permalink:"/docs/Rust/section7/iterators"},next:{title:"Macros in Rust",permalink:"/docs/Rust/section7/macros"}},l=[{value:"Defining &amp; Using Closures",id:"defining--using-closures",children:[{value:"Type Inference",id:"type-inference",children:[]},{value:"Capturing Environments",id:"capturing-environments",children:[]}]},{value:"Try it yourself!",id:"try-it-yourself",children:[]},{value:"What&#39;s going on here?",id:"whats-going-on-here",children:[]}],c={toc:l},u="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Closures are one of Rust's functional programming-esque features that can create ",(0,a.kt)("strong",{parentName:"p"},"anonymous functions"),".  Closures, like functions, execute blocks of logic within.  They are fundamentally different in how they operate and handle ownership."),(0,a.kt)("p",null,"They may even be used as a return type, as shown in examples such as ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap_or_else()"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let some_result: i32 = dangerous_value().unwrap_or_else(|| 42);\n")),(0,a.kt)("p",null,"The two vertical pipes within ",(0,a.kt)("inlineCode",{parentName:"p"},"unwrap_or_else")," signify that it is a closure, and 42 is the returned value.  Closures can be used in generics using the ",(0,a.kt)("inlineCode",{parentName:"p"},"Fn")," trait or even as a parameter for an actual function."),(0,a.kt)("h2",{id:"defining--using-closures"},"Defining & Using Closures"),(0,a.kt)("p",null,"Defining closures is similar to defining a variable.  It utilizes two vertical pipes to signify any parameters.  A return type can also be specified as part of the closure.  Closures are called the same way a function is called:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let name = "Bob";\n    // Closure that captures `name` and returns a new string with "Hello, " prepended\n    let greet_closure = |name: &str| -> String {\n        format!("Hello, {}!", name)\n    };\n    // It is called the same way a function is\n    let greeting = greet_closure(name);\n    println!("{}", greeting); // Prints "Hello, Bob!"\n}\n')),(0,a.kt)("h3",{id:"type-inference"},"Type Inference"),(0,a.kt)("p",null,"Where functions require explicit type declarations for their parameter and return types, closures don't have this requirement.  They are able to infer both types, depending on how one uses it:"),(0,a.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,a.kt)("div",{parentName:"div",className:"admonition-heading"},(0,a.kt)("h5",{parentName:"div"},(0,a.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,a.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,a.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,a.kt)("div",{parentName:"div",className:"admonition-content"},(0,a.kt)("p",{parentName:"div"},"This also can shorten the closure into one line, as the curly brackets are omitted, and the return type is directly specified.  If this was a multi-line closure, then curly brackets would be required."))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let name = "Bob";\nlet greet_closure = |name| format!("Hello, {}!", name);\n// It is called the same way a function is.  The types are inferred here!\n// `name` is of type &str, meaning it now expects it from thereon.\nlet greeting = greet_closure(name);\nprintln!("{}", greeting); // Prints "Hello, Bob!"\n// This will fail!\nlet greeting_two = greet_closure(123);\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"18 | let greeting = greet_closure(123);\n   |                ------------- ^^^ expected `&str`, found integer\n   |                |\n   |                arguments to this function are incorrect\n")),(0,a.kt)("h3",{id:"capturing-environments"},"Capturing Environments"),(0,a.kt)("p",null,"Unlike functions, closures can capture their environment.  A closure can utilize local variables within a scope that the closure is defined:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'fn main() {\n    let name = "Bob";\n    // This closure has no arguments now but can use the `name`\n    // variable defined in the main scope.\n    let greet_closure_that_captures = || format!("Hello Captured, {}!", name);\n    // It is called the same way a function is\n    let greeting_two = greet_closure_that_captures();\n    println!("{}", greeting); /\n}\n')),(0,a.kt)("h2",{id:"try-it-yourself"},"Try it yourself!"),(0,a.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++let+name+%3D+%22Bob%22%3B%0A++++let+greet_closure+%3D+%7Cname%7C+format%21%28%22Hello%2C+%7B%7D%21%22%2C+name%29%3B%0A++++%2F%2F+It+is+called+the+same+way+a+function+is.+The+types+are+inferred+here%21%0A++++%2F%2F+%60name%60+is+of+type+%26str%2C+meaning+it+now+expects+it+from+thereon.%0A++++let+greeting+%3D+greet_closure%28name%29%3B%0A++++println%21%28%22%7B%7D%22%2C+greeting%29%3B+%2F%2F+Prints+%22Hello%2C+Bob%21%22%0A%0A++++%2F%2F+This+will+fail%21%0A++++%2F%2F+let+greeting+%3D+greet_closure%28123%29%3B%0A++++%0A++++%2F%2F+Closure+that+captures+%60name%60+and+returns+a+new+string+with+%22Hello%2C+%22+prepended%0A++++let+greet_closure_that_captures+%3D+%7C%7C+format%21%28%22Hello+Captured%2C+%7B%7D%21%22%2C+name%29%3B%0A++++%2F%2F+It+is+called+the+same+way+a+function+is%0A++++let+greeting_two+%3D+greet_closure_that_captures%28%29%3B%0A++++println%21%28%22%7B%7D%22%2C+greeting_two%29%3B+%2F%2F+Prints+%22Hello%2C+Bob%21%22%0A%7D%0A"}),(0,a.kt)("h2",{id:"whats-going-on-here"},"What's going on here?"),(0,a.kt)("p",null,"The code above showcases two examples of closures in use.  The first example accepts a parameter, of which its type is inferred.  The second example removes the parameter and instead captures a variable outside of the closure but within the same scope."))}p.isMDXComponent=!0}}]);