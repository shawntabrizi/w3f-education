"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9481],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),d=a,h=u["".concat(s,".").concat(d)]||u[d]||m[d]||o;return n?r.createElement(h,i(i({ref:t},p),{},{components:n})):r.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[u]="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},346:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const o={id:"iterators",title:"Iterators in Rust",sidebar_label:"Iterators",description:"Learn how to use iterators in Rust."},i=void 0,l={unversionedId:"Rust/section7/iterators",id:"Rust/section7/iterators",title:"Iterators in Rust",description:"Learn how to use iterators in Rust.",source:"@site/docs/Rust/section7/iterators.md",sourceDirName:"Rust/section7",slug:"/Rust/section7/iterators",permalink:"/docs/Rust/section7/iterators",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section7/iterators.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1683227258,formattedLastUpdatedAt:"May 4, 2023",frontMatter:{id:"iterators",title:"Iterators in Rust",sidebar_label:"Iterators",description:"Learn how to use iterators in Rust."},sidebar:"rust",previous:{title:"Intro to Advanced Rust - Iterators & Closures",permalink:"/docs/Rust/section7/"},next:{title:"Closures",permalink:"/docs/Rust/section7/closures"}},s={},c=[{value:"Creating an Iterator",id:"creating-an-iterator",level:2},{value:"A closer look at the <code>Iterator</code> trait",id:"a-closer-look-at-the-iterator-trait",level:2},{value:"&quot;Consuming&quot; An Iterator &amp; Iterator Methods",id:"consuming-an-iterator--iterator-methods",level:2},{value:"Using .collect()",id:"using-collect",level:3},{value:"Loops vs Iterators - when to use which?",id:"loops-vs-iterators---when-to-use-which",level:2},{value:"Try it yourself!",id:"try-it-yourself",level:2},{value:"What&#39;s going on here?",id:"whats-going-on-here",level:2}],p={toc:c},u="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Iterators in Rust allow you to perform tasks sequentially on a series of items while knowing the end of the sequence.  ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," is a trait that, once implemented, handles many of the nuances of safely looping through collections.  Iterators are ",(0,a.kt)("strong",{parentName:"p"},"lazy"),", meaning they are only used when called upon."),(0,a.kt)("h2",{id:"creating-an-iterator"},"Creating an Iterator"),(0,a.kt)("p",null,"Most collections we discussed earlier have the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," trait already implemented.  The most common usage of iterators regards arrays or vectors, and they are often used as an alternative for loops:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'let my_vec = vec![1, 2, 3, 4, 5];\n\n// Call the `.iter()` method on `Vec`:\nlet iter = my_vec.iter();\nfor val in iter {\n    println!("Value: {}", val);\n}\n// Optionally, call it in-line:\nlet my_vec = vec![1, 2, 3, 4, 5];\nfor val in my_vec.iter() {\n    println!("Value: {}", val);\n}\n')),(0,a.kt)("p",null,"You may notice that this looks familiar to a regular ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop.  This will be discussed in more depth in a later section, but know they are different!"),(0,a.kt)("h2",{id:"a-closer-look-at-the-iterator-trait"},"A closer look at the ",(0,a.kt)("inlineCode",{parentName:"h2"},"Iterator")," trait"),(0,a.kt)("p",null,"Let's examine the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," trait itself:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"pub trait Iterator {\n    type Item;\n\n    fn next(&mut self) -> Option<Self::Item>;\n    // methods with default implementations elided\n}\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"next()")," method is the heart of an ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),"'s functionality, as it's the only method needed to implement the ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," trait.  ",(0,a.kt)("inlineCode",{parentName:"p"},"next()")," returns the next item as ",(0,a.kt)("inlineCode",{parentName:"p"},"Some(value)")," from the iterator, and returns ",(0,a.kt)("inlineCode",{parentName:"p"},"None")," once it's complete."),(0,a.kt)("p",null,"Notice that although ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator")," can iterate over many types, it uses an associated type, ",(0,a.kt)("inlineCode",{parentName:"p"},"Item"),".  Using an associated type allows the type implementing the trait to specify the desired outcome, versus a generic would have the developer impose some type that may be incorrect."),(0,a.kt)("h2",{id:"consuming-an-iterator--iterator-methods"},'"Consuming" An Iterator & Iterator Methods'),(0,a.kt)("p",null,"As a result of implementing ",(0,a.kt)("inlineCode",{parentName:"p"},"Iterator"),", one can use a few key methods to modify a sequence of items.  For more information on available methods, it is highly encouraged to read through the Rust documentation for the ",(0,a.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/iter/trait.Iterator.html"},(0,a.kt)("inlineCode",{parentName:"a"},"Iterator"))," trait."),(0,a.kt)("p",null,"Some methods consume an iterator, meaning they call the ",(0,a.kt)("inlineCode",{parentName:"p"},"next( )")," method within their implementation.  An example is ",(0,a.kt)("inlineCode",{parentName:"p"},".sum()"),", which collectively adds all items by calling ",(0,a.kt)("inlineCode",{parentName:"p"},"next()")," until the iterator has reached its end:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let my_vec = vec![1, 2, 3, 4, 5];\nlet sum = my_vec.iter().sum();\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},".map()")," method is very commonly used.  It takes a closure, performs an operation over each item in the iterator, and returns an iterator.  This does not modify the previous iterator, rather it returns a new one with modified values:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let my_vec = vec![1, 2, 3, 4, 5];\n// Returns a new iterator that adds `1` to each item\nmy_vec.iter().map(|x| x + 1);\n")),(0,a.kt)("p",null,"Another method that operates similarly is ",(0,a.kt)("inlineCode",{parentName:"p"},"filter()")," , which returns an iterator of filtered values based on a conditional statement within the closure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let my_vec = vec![1, 2, 3, 4, 5];\n// Returns a new iterator that adds `1` to each item\nmy_vec.iter().filter(|x| *x % 2 == 0);\n")),(0,a.kt)("h3",{id:"using-collect"},"Using .collect()"),(0,a.kt)("p",null,"Using ",(0,a.kt)("inlineCode",{parentName:"p"},"collect()"),", you can gather the values of an iterator and back into a vector that represents the operation you performed on it:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"let my_vec = vec![1, 2, 3, 4, 5];\n// Returns a new iterator containing only even numbers\nlet filter_iter = my_vec.iter().filter(|x| *x % 2 == 0);\n// Returns a new iterator that adds `1` to each item\nlet map_iter = my_vec.iter().map(|x| x + 1);\n\n// Collect into a filtered Vec\nlet even: Vec<_> = filter_iter.collect(); // [2, 4]\n// Collect into a mapped Vec\nlet plus_one: Vec<_> = map_iter.collect(); // [2, 3, 4, 5, 6]\n\n")),(0,a.kt)("p",null,"As some of these methods return an iterator, it's possible to chain them:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"// Both maps then filter on the returned iterator from `map`\nlet chained_iter = my_vec.iter().map(|x| x + 1).filter(|x| *x % 2 == 0);\n")),(0,a.kt)("h2",{id:"loops-vs-iterators---when-to-use-which"},"Loops vs Iterators - when to use which?"),(0,a.kt)("p",null,"In the previous section, a piece of code looked just like a ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop that was covered in the Loops module:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'    let my_vec = vec![1, 2, 3, 4, 5];\n    for val in my_vec.iter() {\n        println!("Value: {}", val);\n    }\n')),(0,a.kt)("p",null,"At first glance, this appears to be the same syntax and functionality as a normal ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'    let my_vec = vec![1, 2, 3, 4, 5];\n    for val in my_vec {\n        println!("Value: {}", val);\n    }\n')),(0,a.kt)("p",null,"Both serve the same purpose but behave differently.  Iterators operate on ",(0,a.kt)("strong",{parentName:"p"},"references"),", whereas a ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop directly takes possession of the value for the loop's scope.  Calling:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"for val in my_vec.iter() {}\n")),(0,a.kt)("p",null,"It is effectively the same as calling:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"for val in &my_vec {}\n")),(0,a.kt)("p",null,"It is generally a better design decision to utilize a reference-based approach, as ",(0,a.kt)("inlineCode",{parentName:"p"},"my_vec")," would be unusable after a traditional ",(0,a.kt)("inlineCode",{parentName:"p"},"for")," loop that takes ownership."),(0,a.kt)("h2",{id:"try-it-yourself"},"Try it yourself!"),(0,a.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++let+my_vec+%3D+vec%21%5B1%2C+2%2C+3%2C+4%2C+5%5D%3B%0A++++%2F%2F+Returns+a+new+iterator+that+only+contains+even+numbers%0A++++let+filter_iter+%3D+my_vec.iter%28%29.filter%28%7Cx%7C+*x+%25+2+%3D%3D+0%29%3B%0A++++%2F%2F+Returns+a+new+iterator+that+adds+%601%60+to+each+item%0A++++let+map_iter+%3D+my_vec.iter%28%29.map%28%7Cx%7C+x+%2B+1%29%3B%0A++++%2F%2F+Chain+iterators%21%0A++++let+chained_iter+%3D+my_vec.iter%28%29.map%28%7Cx%7C+x+%2B+1%29.filter%28%7Cx%7C+*x+%25+2+%3D%3D+0%29%3B%0A%0A++++%2F%2F+Collect+into+a+filtered+Vec%0A++++let+even%3A+Vec%3C_%3E+%3D+filter_iter.collect%28%29%3B%0A++++%2F%2F+Collect+into+a+mapped+Vec%0A++++let+plus_one%3A+Vec%3C_%3E+%3D+map_iter.collect%28%29%3B%0A++++%2F%2F+Collect+into+a+Vec+that+combined+the+two+operations%0A++++let+chained%3A+Vec%3C_%3E+%3D+chained_iter.collect%28%29%3B%0A++++%2F%2F+Consume%21%0A++++let+sum%3A+i32+%3D+my_vec.iter%28%29.sum%28%29%3B%0A%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+even%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+plus_one%29%3B%0A++++println%21%28%22%7B%3A%3F%7D%22%2C+chained%29%3B%0A++++println%21%28%22%7B%7D%22%2C+sum%29%3B%0A%7D%0A"}),(0,a.kt)("h2",{id:"whats-going-on-here"},"What's going on here?"),(0,a.kt)("p",null,"The code features a collection of various iterators stemming from the same ",(0,a.kt)("inlineCode",{parentName:"p"},"Vec"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"my_vec"),".  Iterators do not directly modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"Vec"),". Rather each operation returns a new iterator with values that may be modified, which is the case with ",(0,a.kt)("inlineCode",{parentName:"p"},"map()"),"."))}m.isMDXComponent=!0}}]);