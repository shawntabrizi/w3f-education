"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5605],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),p=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(o.Provider,{value:t},e.children)},d="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(a),m=r,h=d["".concat(o,".").concat(m)]||d[m]||c[m]||i;return a?n.createElement(h,l(l({ref:t},u),{},{components:a})):n.createElement(h,l({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=m;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s[d]="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},2342:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>l,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(7462),r=(a(7294),a(3905));const i={id:"data-types",title:"Data Types in Rust",sidebar_label:"Data Types",description:"Learn what data types are and which basic ones exist."},l=void 0,s={unversionedId:"Rust/section2/data-types",id:"Rust/section2/data-types",title:"Data Types in Rust",description:"Learn what data types are and which basic ones exist.",source:"@site/docs/Rust/section2/data-types.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/data-types",permalink:"/docs/Rust/section2/data-types",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/data-types.md",tags:[],version:"current",lastUpdatedBy:"Radha",lastUpdatedAt:1682934958,formattedLastUpdatedAt:"May 1, 2023",frontMatter:{id:"data-types",title:"Data Types in Rust",sidebar_label:"Data Types",description:"Learn what data types are and which basic ones exist."},sidebar:"rust",previous:{title:"The Heap vs. The Stack",permalink:"/docs/Rust/section2/heap-vs-stack"},next:{title:"Functions & Comments",permalink:"/docs/Rust/section2/functions-comments"}},o={},p=[{value:"Scalar Types",id:"scalar-types",level:2},{value:"Integers &amp; Floating-point Types",id:"integers--floating-point-types",level:3},{value:"Floating point numbers",id:"floating-point-numbers",level:4},{value:"Operators",id:"operators",level:4},{value:"Boolean Types",id:"boolean-types",level:3},{value:"Character Type",id:"character-type",level:3},{value:"Compound Types",id:"compound-types",level:2},{value:"Tuples",id:"tuples",level:3},{value:"Arrays",id:"arrays",level:3},{value:"Try it yourself!",id:"try-it-yourself",level:2},{value:"What is happening here?",id:"what-is-happening-here",level:2}],u={toc:p},d="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(d,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As mentioned before in the introduction of this course, one of Rust's main objectives is to have a robust, compile-time type system.  Just as the immutability of variables helps with safety, having types in Rust greatly aids in ensuring that data is flowing as it should throughout the program."),(0,r.kt)("p",null,"Rust has two kinds of ",(0,r.kt)("strong",{parentName:"p"},"primitive"),", or base, data types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Scalar - single point types, such as numbers and booleans (",(0,r.kt)("inlineCode",{parentName:"li"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"false")," statements)"),(0,r.kt)("li",{parentName:"ul"},"Compound - arrays, and tuples")),(0,r.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/G9I-HdPsLmo",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),(0,r.kt)("h2",{id:"scalar-types"},"Scalar Types"),(0,r.kt)("p",null,"Scalar types represent a single value, such as a number or boolean.  Rust has four core Scalar types, which you have most likely seen in other programming languages: "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Integers"),(0,r.kt)("li",{parentName:"ul"},"Floating-point numbers"),(0,r.kt)("li",{parentName:"ul"},"Booleans"),(0,r.kt)("li",{parentName:"ul"},"Characters")),(0,r.kt)("h3",{id:"integers--floating-point-types"},"Integers & Floating-point Types"),(0,r.kt)("p",null,"An integer in Rust is the same as in mathematics - a non-fractional, whole number that can be either positive or negative.  There are two types of integers: ",(0,r.kt)("em",{parentName:"p"},"signed")," (real, positive numbers) and ",(0,r.kt)("em",{parentName:"p"},"unsigned")," (real, negative ",(0,r.kt)("em",{parentName:"p"},"or")," positive numbers).  "),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Signed integers are denoted by the ",(0,r.kt)("inlineCode",{parentName:"li"},"i"),", followed by the length of the number: ",(0,r.kt)("inlineCode",{parentName:"li"},"i32"),".  "),(0,r.kt)("li",{parentName:"ul"},"Unsigned integers start with ",(0,r.kt)("inlineCode",{parentName:"li"},"u,")," followed by the length of the number: ",(0,r.kt)("inlineCode",{parentName:"li"},"u32"),".")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"32")," that follows whether an integer is signed or unsigned denotes the length of the number.  Take this table from the ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/ch03-02-data-types.html"},"Rust Book"),", which states all possible integer variants: "),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Length"),(0,r.kt)("th",{parentName:"tr",align:null},"Signed"),(0,r.kt)("th",{parentName:"tr",align:null},"Unsigned"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"8-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i8"),(0,r.kt)("td",{parentName:"tr",align:null},"u8")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"16-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i16"),(0,r.kt)("td",{parentName:"tr",align:null},"u16")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"32-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i32"),(0,r.kt)("td",{parentName:"tr",align:null},"u32")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"64-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i64"),(0,r.kt)("td",{parentName:"tr",align:null},"u64")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"128-bit"),(0,r.kt)("td",{parentName:"tr",align:null},"i128"),(0,r.kt)("td",{parentName:"tr",align:null},"u128")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"arch"),(0,r.kt)("td",{parentName:"tr",align:null},"isize"),(0,r.kt)("td",{parentName:"tr",align:null},"usize")))),(0,r.kt)("p",null,"The length or size of the integer is always explicitly declared.  Rust has a set of defaults for inferring types, such as integers defaulting to the ",(0,r.kt)("inlineCode",{parentName:"p"},"i32")," type.  ",(0,r.kt)("inlineCode",{parentName:"p"},"usize")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"isize")," depend on your machine's architecture, meaning they are either 32, or 64 bit in size."),(0,r.kt)("p",null,"Here are some common ways to declare an integer, some formats less traditional than others:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\n// Defaults to i32.\nlet default = 10;\n\n// Explicitly declare this variable as an unsigned, 64-bit integer:\nlet sixty_four_bit_int: u64 = 10;\n\n// You can also declare integer literals like so:\nlet big_number = 65_550; // 65,550\n\n// Another way to specify the type can be done with this syntax, with the type following the number:\nlet short_hand = 455u32;\n\n// Declaring a hex literal is possible!\nlet hex = 0x001;\n\n// You can also represent characters as unsigned 8-bit numbers.  This will get very useful later on:\nlet word_as_bytes: u8 = b'F';\n\n")),(0,r.kt)("p",null,"Lastly, as integers do have a size, integer overflow is possible if you exceed the limit of a given type.  For example, the type ",(0,r.kt)("inlineCode",{parentName:"p"},"u8")," has a minimum of 0 and a maximum of 255, meaning 256 would cause a panic.  As the Rust compiler doesn't check for overflows, there are some additional functions you can use to ensure that adding or subtracting is always safe and won't cause a runtime error.  We'll learn more about those later on."),(0,r.kt)("h4",{id:"floating-point-numbers"},"Floating point numbers"),(0,r.kt)("p",null,"Rust has two floating number types: ' f32",(0,r.kt)("inlineCode",{parentName:"p"},"(32-bit) and"),"f64` (64-bit).  Floating point numbers, unlike integers, are fractional, meaning they contain decimal points to represent parts of whole numbers:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"f32")," has single precision accuracy, whereas ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," has double-precision accuracy.  ",(0,r.kt)("inlineCode",{parentName:"p"},"f64")," is the default type for floating point numbers in Rust:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet floating_double: f64 = 1.11;\n\nlet floating_single: f32 = 1.4;\n\nlet also_floating_double = 1.45;\n\n")),(0,r.kt)("h4",{id:"operators"},"Operators"),(0,r.kt)("p",null,"As in any other programming language, there are a set of operators that allow for basic mathematics to be performed:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet addition = 1 + 1; // 2\nlet subtraction = 10 - 5; // 5\nlet division = 8 / 4; // 2\nlet multiplication = 4 * 4; // 16\n\n")),(0,r.kt)("p",null,"Likewise, Rust also supports bitwise operators.  A full list of Rust's operators and symbols may be ",(0,r.kt)("a",{parentName:"p",href:"https://doc.rust-lang.org/book/appendix-02-operators.html"},"found here.")),(0,r.kt)("h3",{id:"boolean-types"},"Boolean Types"),(0,r.kt)("p",null,"A boolean value can only have two possible states: ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"false"),".  Declaring a boolean in Rust is simple:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet i_am_true = true;\n\n// Usually, it's easy to infer a bool type; however good to show explicit type assignments.\nlet i_am_false: bool = false; \n\n")),(0,r.kt)("p",null,"This opens up many possibilities for ",(0,r.kt)("strong",{parentName:"p"},"branching logic")," in our Rust programs, of which we'll cover later."),(0,r.kt)("h3",{id:"character-type"},"Character Type"),(0,r.kt)("p",null,"The character, or ",(0,r.kt)("inlineCode",{parentName:"p"},"char")," type in Rust is the basic building block for alphabetic values.  It simply declares a single character, which is encased by single quotes.  At its core, it represents a ",(0,r.kt)("a",{parentName:"p",href:"https://home.unicode.org/"},"Unicode Scalar Value"),", supporting a plethora of characters as well as zero-width spaces:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// Both are valid Unicode characters!\nlet the_letter_a = 'A';\nlet the_moon = '\ud83c\udf12';\n")),(0,r.kt)("h2",{id:"compound-types"},"Compound Types"),(0,r.kt)("p",null,"Scalar types define how variables can hold a single value at a time.  Compound types can hold multiple values under the same, unifying type."),(0,r.kt)("p",null,"There are two primary kinds of compound types - tuples and arrays."),(0,r.kt)("h3",{id:"tuples"},"Tuples"),(0,r.kt)("p",null,"A ",(0,r.kt)("em",{parentName:"p"},"tuple")," is a way to combine multiple values and types into a single, compound type.  It can be useful for describing a set of varying values which have some relationship to one another."),(0,r.kt)("p",null,"The syntax for writing a tuple is as follows.  Note that the type annotations are optional: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_tuple: (u32, f32, char) = (5, 5.5, '\ud83c\udf12'); // The explicit type annotations here are optional, \n\n")),(0,r.kt)("p",null,"There are a couple of ways to access the elements within a tuple.  The first way merely involves fetching them in order, starting at ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet unsigned_32: u32 = my_tuple.0;\nlet floating_32: f32 = my_tuple.1;\nlet moon: char = my_tuple.2;\n\n")),(0,r.kt)("p",null,"You may also use pattern matching to access these elements.  The following syntax constructs a pattern out of the above:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_tuple: (u32, f32, char) = (5, 5.5, '\ud83c\udf12'); // The explicit type annotations here are optional, \n\nlet (unsigned_32, floating_32, moon) = my_tuple;\n")),(0,r.kt)("p",null,"Tuples can have elements that are of varying types, as seen above.  They can be useful in describing a set, fixed amount of elements, such as a set of coordinates:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet location: (i32, i32) = (10, 45);\n\n")),(0,r.kt)("h3",{id:"arrays"},"Arrays"),(0,r.kt)("p",null,"An ",(0,r.kt)("strong",{parentName:"p"},"array")," is a collection of multiple values.  Unlike tuples, these values must be the same type.  Arrays are like lists - and are useful for having a fixed amount of types and having data stored on the ",(0,r.kt)("strong",{parentName:"p"},"stack"),".  "),(0,r.kt)("p",null,"Arrays are typically used less often than",(0,r.kt)("strong",{parentName:"p"}," vectors"),", which is a type of collection that includes a number of convenience methods for sorting and manipulating the values within the collection.  Vectors can grow and shrink in size, as the data is managed by the ",(0,r.kt)("strong",{parentName:"p"},"heap"),", whereas arrays are fixed-length and stored on the stack."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nlet my_pets_ages: [i32; 3] = [4, 5, 3];\n\n")),(0,r.kt)("p",null,"Notice in the type declaration, ",(0,r.kt)("inlineCode",{parentName:"p"},"[i32; 3]"),", that the first part denotes the type of ",(0,r.kt)("strong",{parentName:"p"},"each element")," within the array with each type being an ",(0,r.kt)("inlineCode",{parentName:"p"},"i32"),".  The second portion within the square brackets, ",(0,r.kt)("inlineCode",{parentName:"p"},"3"),", denotes the ",(0,r.kt)("strong",{parentName:"p"},"maximum amount of elements an array can hold"),".  It's possible to do without this explicit declaration, as the compiler will interpret it as it stands. "),(0,r.kt)("p",null,"To access specific elements within an array is done using square brackets, along with the index of the element you wish to access.  As with tuples, all arrays start at index ",(0,r.kt)("inlineCode",{parentName:"p"},"0"),": "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet course_modules = ["Module 1", "Module 2", "Module 3","Module 4", "Module 5"];\n// Use the [ index ] syntax to access a particular element.\nlet module_one = course_modules[0];\n')),(0,r.kt)("p",null,"Be forewarned - it's possible to access an element that doesn't exist, which would cause a runtime error."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nerror: this operation will panic at runtime\n  --\x3e src/main.rs:32:18\n   |\n32 | let module_six = course_modules[5];\n   |                  ^^^^^^^^^^^^^^^^^ index out of bounds: the length is 5 but the index is 5\n   |\n   = note: `#[deny(unconditional_panic)]` on by default\n\n")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"How can the Rust compiler know when a runtime error will occur?  Because an array is fixed length, it knows the maximum index that can be accessed, in this case, ",(0,r.kt)("inlineCode",{parentName:"p"},"4"),".  The compiler disallows it before the program is even compiled.  However, if this index is a user-generated value, which can only exist at runtime, then a panic will occur and the program will stop.  The fact that the program stops is a security measure as it prevents any possibly invalid memory from being accessed and exploited.")),(0,r.kt)("h2",{id:"try-it-yourself"},"Try it yourself!"),(0,r.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+As+always%2C+start+with+an+entry+point+into+our+program%0Afn+main%28%29+%7B%0A%0A%2F%2F+Let%27s+start+by+creating+a+list%2C+or+an+array+of+the+course%27s+modules%3A%0A%0Alet+course_modules+%3D+%5B%22Module+1%22%2C+%22Module+2%22%2C+%22Module+3%22%2C%22Module+4%22%2C+%22Module+5%22%5D%3B%0A%0A%2F%2F+Next%2C+let%27s+print+each+one+out+till+it+reaches+the+end.+You%27ll+learn+about+loops%2C+but+just%0A%2F%2F+know+that+this+goes+over+each+element+within+the+array+until+it%27s+finished.%0A++++for+module+in+course_modules+%7B%0A++++++++println%21%28%22%7Bmodule%7D%22%29%0A++++%7D%0A%2F%2F+Great%2C+it+prints%21+Now%2C+suppose+we+try+to+add+another+element+to+the+array.%0A%2F%2F+This+is+done+using+the+%60.push%60+method+to+append%2C+or+push+another+element.%0A%2F%2F+course_modules.push%28%22Module+6%22%29%3B%0A%0A%2F%2F+It+doesn%27t+compile%21+Can+you+read+the+message+and+figure+out+why%3F%0A%0A%2F%2F+Lets+use+our+knowledge+of+shadow+variables+and+remake+this+array.%0A%2F%2F+We+can+see+that+the+compiler+states+that+it+is+%60%5B%26str%3B+5%5D%60%2C+meaning%0A%2F%2F+It+was+expecting+5+elements%2C+not+6%2C+hence+it+panicked+when+we+added+the+sixth+module.%0A%0A%2F%2F+Try+creating+an+array+of+tuples%2C+and+printing+them+as+we+did+above.+%0A%2F%2F+Don%27t+forget+to+comment+out+or+remove+the+line+that+breaks+the+program%0A%0Alet+tuple_array+%3D+%5B%28%22hi%22%2C+3%29%5D%3B%0A+++for+tuple+in+tuple_array+%7B%0A++++++++println%21%28%22%7B%3A%3F%7D%22%2C+tuple%29%0A++++%7D%0A%7D"}),(0,r.kt)("h2",{id:"what-is-happening-here"},"What is happening here?"),(0,r.kt)("p",null,"We define an array a fixed-length list of values of the same type stored on the stack.  We can successfully access and print the items in this list; however, the compiler prevents any out-of-bounds access.  It also prevents any additional items from being appended, as the array has a fixed length in memory."),(0,r.kt)("p",null,"Next, we create an array of ",(0,r.kt)("em",{parentName:"p"},"tuples"),", which would look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet tuple_array = [("hi", 3), ("hello", 1)];\n   for tuple in tuple_array {\n        println!("{:?}", tuple)\n    }\n\n')))}c.isMDXComponent=!0}}]);