"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9594],{3905:(e,t,o)=>{o.d(t,{Zo:()=>d,kt:()=>f});var n=o(7294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,n,i=function(e,t){if(null==e)return{};var o,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var o=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(o),p=i,f=h["".concat(l,".").concat(p)]||h[p]||u[p]||a;return o?n.createElement(f,r(r({ref:t},d),{},{components:o})):n.createElement(f,r({ref:t},d))}));function f(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=o.length,r=new Array(a);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<a;c++)r[c]=o[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,o)}p.displayName="MDXCreateElement"},2813:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=o(7462),i=(o(7294),o(3905));const a={id:"consensus"},r="Polkadot Network Consensus",s={unversionedId:"Polkadot/Module3/consensus",id:"Polkadot/Module3/consensus",title:"Polkadot Network Consensus",description:"We need to be able to revert the chain until we know with good probability that all parachains are",source:"@site/docs/Polkadot/Module3/consensus.md",sourceDirName:"Polkadot/Module3",slug:"/Polkadot/Module3/consensus",permalink:"/docs/Polkadot/Module3/consensus",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module3/consensus.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"consensus"},sidebar:"polkadot",previous:{title:"Treasury",permalink:"/docs/Polkadot/Module2/treasury"},next:{title:"Nominated Proof of Staking",permalink:"/docs/Polkadot/Module3/npos"}},l={},c=[{value:"BABE",id:"babe",level:2},{value:"Relative Time Protocol",id:"relative-time-protocol",level:3},{value:"GRANDPA Finality Gadget",id:"grandpa-finality-gadget",level:2}],d={toc:c},h="wrapper";function u(e){let{components:t,...o}=e;return(0,i.kt)(h,(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"polkadot-network-consensus"},"Polkadot Network Consensus"),(0,i.kt)("p",null,"We need to be able to revert the chain until we know with good probability that all parachains are\ncorrect. This means that we need to be able to reorganise the chain and for that the chain needs to\nbe capable of forking. Thus we use a block production mechanism, BABE, that while run by validators,\nhas similar properties to proof-of-work chains. Specifically, we can use the longest chain rule as\npart of our consensus, and the next block producer is not known in advance. On its own BABE would\nrequire us to wait a long time from the moment a block is produced to the moment it is finalised,\ni.e. when we can be confident that with high probability the block will never be reverted. Slow\nfinality is required in some circumstances to deal with challenges to availability. Most of the\ntime, however, we would prefer to finalise blocks much faster. For this purpose, validators finalise\nblocks using GRANDPA, a finality gadget that is cleanly separated from block production. This\nseparation makes it very adaptive and here allows us to delay finalising blocks until challenges are\ndealt with, without slowing down block production. GRANDPA gets Byzantine agreement on finalised\nblocks and will allow us to prove to an entity that keeps track of the validator set which blocks\nare finalised, which will be important for bridges."),(0,i.kt)("h2",{id:"babe"},"BABE"),(0,i.kt)("p",null,'In Polkadot, we produce relay chain blocks using our Blind Assignment for Blockchain Extension\nprotocol (BABE). BABE assigns validators randomly to block production slots using the random- ness\ngenerated with blocks. A block production slot is a division of time when a block producer may\nproduce a block. Note, that time is not universally agreed on, which we will address later. These\nassignments are completely private until the assigned validators produce their blocks. Therefore, we\nuse \\Blind Assignment" in the protocol name. BABE is similar to Ouroboros Praos with some\nsignificant differences in the chain selection rule and timing assumptions. In BABE, we may have\nslots without any assignment which we call empty slot. In order to fill the empty slots, we have a\nsecondary block production mechanism based on Aura that assigns validators to slots publicly. We\nnote that these blocks do not contribute to the security of BABE since the best chain selection and\nthe random number generation algorithms work as if Aura blocks do not exist. Therefore, next we only\ndescribe BABE together with its security properties.'),(0,i.kt)("h3",{id:"relative-time-protocol"},"Relative Time Protocol"),(0,i.kt)("p",null,"Relative Time Protocol: The elected validators for a slot need to know when the right time is to\nproduce a block for the consistency and the security of BABE. For this, validators uses their local\ncomputer clock which is not adjusted by any centralized clock adjustment protocols such as the\nNetwork Time Protocol. Instead, they keep their clock synchronised with the other validators with\nthe relative time protocol."),(0,i.kt)("p",null,"In BABE, we assume that after the genesis block is released, elected validators of the first epoch\nstore the arrival time of the genesis block with respect to their local clock. Then, they mark the\nbeginning time of the first slot and increment the slot number every T seconds. After this point,\nthey periodically run the relative algorithm not to lose the synchronisation with others because of\ntheir local clock drifts. In addition to this, a validator who joins after the genesis block runs\nthe relative time algorithm to be synchronised with the other validators."),(0,i.kt)("p",null,"As mentioned above, we want a finalisation mechanism that is exible and separated from block\nproduction, which is achieved by GRANDPA. The only modification to BABE required for it to work with\nGRANDPA is to change the fork-choice rule: instead of building on the longest chain, a validator\nproducing a block should build on the longest chain including all blocks that it sees as finalised.\nGRANDPA can work with many different block production mechanisms and it will be possible to switch\nout BABE with another. Intuitively GRANDPA is a Byzantine agreement protocol that works to agree on\na chain, out of many possible forks, by following some simpler fork choice rule, which together with\nthe block production mechanism would give probabilistic finality if GRANDPA itself stopped\nfinalising blocks. We want to be able to agree on many blocks at once, in contrast to single-block\nByzantine agreement protocols. We assume that we can ask the fork choice rule for the best block\ngiven a particular block. The basic idea is that we want to reach Byzantine agreement on the prefix\nof the chain that everyone agrees on. To make this more robust, we try to agree on the prefix of the\nchain that 2/3 of validators agree on."),(0,i.kt)("h2",{id:"grandpa-finality-gadget"},"GRANDPA Finality Gadget"),(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/0shPS6SXPKE",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))}u.isMDXComponent=!0}}]);