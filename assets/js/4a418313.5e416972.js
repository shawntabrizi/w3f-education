"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[6175],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=l(n),p=o,f=h["".concat(c,".").concat(p)]||h[p]||u[p]||r;return n?a.createElement(f,i(i({ref:t},d),{},{components:n})):a.createElement(f,i({ref:t},d))}));function f(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[h]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<r;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1733:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),o=(n(7294),n(3905));const r={id:"explorenetwork"},i="Exploring Polkadot Network",s={unversionedId:"Polkadot/Module2/explorenetwork",id:"Polkadot/Module2/explorenetwork",title:"Exploring Polkadot Network",description:"Polkadot as a State Machine",source:"@site/docs/Polkadot/Module2/explorenetwork.md",sourceDirName:"Polkadot/Module2",slug:"/Polkadot/Module2/explorenetwork",permalink:"/docs/Polkadot/Module2/explorenetwork",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module2/explorenetwork.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"explorenetwork"},sidebar:"polkadot",previous:{title:"DOT Token Utility",permalink:"/docs/Polkadot/Module2/dotutility"},next:{title:"On-Chain Governance",permalink:"/docs/Polkadot/Module2/governance"}},c={},l=[{value:"Polkadot as a State Machine",id:"polkadot-as-a-state-machine",level:2},{value:"State",id:"state",level:2},{value:"State Transitions",id:"state-transitions",level:2},{value:"Extrinsics",id:"extrinsics",level:2},{value:"Transaction Fees",id:"transaction-fees",level:2}],d={toc:l},h="wrapper";function u(e){let{components:t,...n}=e;return(0,o.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"exploring-polkadot-network"},"Exploring Polkadot Network"),(0,o.kt)("h2",{id:"polkadot-as-a-state-machine"},"Polkadot as a State Machine"),(0,o.kt)("p",null,"Polkadot is a replicated sharded state machine where shards are the parachains and the Polkadot\nrelay chain is part of the protocol ensuring global consensus among all the parachains. Therefore,\nthe Polkadot relay chain protocol, can itself be considered as a replicated state machine on its\nown. In this sense, this section describes the relay chain protocol by specifying the state machine\ngoverning the relay chain. To that end, we describe the relay chain state and the detail of state\ntransition governed by transactions grouped in the relay chain blocks."),(0,o.kt)("h2",{id:"state"},"State"),(0,o.kt)("p",null,"The state is represented through the use of an associative array data structure composed by a\ncollection of (key; value) pairs where each key is unique. There is no assumption on the format of\nthe key or the value stored under it besides the fact that they both the key and the value need to\nbe finite byte arrays. The (key; value) pairs which comprise the relay chain state are arranged in a\nMerkle radix-16 tree. The root of this tree canonically identifies the current state of the relay\nchain. The Merkle tree also provides an efficient mean to produce the proof of inclusion for an\nindividual pair in the state. To keep the state size in control, the relay chain state is solely\nused to facilitate the relay chain operations such as staking and identifying validators. The Merkle\nRadix tree is not supposed to store any information regarding the internal operation of the\nparachains."),(0,o.kt)("h2",{id:"state-transitions"},"State Transitions"),(0,o.kt)("p",null,'Like any transaction-based transition system, Polkadot state changes via an executing ordered set of\ninstructions, known as extrinsics. These extrinsics include transactions submitted by the public.\nThey cover any data provided from \\outside" of the machine\'s state which can affect state\ntransition. Polkadot relay chain is divided into two major components, namely the \\Runtime" and the\n\\Runtime environment". The execution logic of the state-transition function is mainly encapsulated\nin the Runtime while all other generic operations, commonly shared among modern blockchain-based\nreplicated state machines, are embedded into the Runtime environment. In particular, the latter is\nin charge of network communication, block production and consensus engines. Runtime functions are\ncompiled into a WebAssembly module and are stored as part of the state. The Runtime environment\ncommunicates the extrinsics to the Runtime and interacts with it to execute the state transition. In\nthis way, the state transition logic itself can be upgraded as a part of the state transition.'),(0,o.kt)("h2",{id:"extrinsics"},"Extrinsics"),(0,o.kt)("p",null,'Extrinsics are the input data supplied to the Polkadot relay-chain state machine to transition to\nnew states. Extrinsics need to be stored into blocks of the relay chain in order to achieve\nconsensus among the state machine replica. Extrinsics are divided into two broad categories namely:\ntransactions and "inherents" which represent data that is inherent to a relay chain block. The\ntimestamp t of a block is an example of inherent extrinsics which must be included in each Polkadot\nrelay chain block.'),(0,o.kt)("p",null,"Transactions are signed and are gossiped around on the network between nodes. In contrast, inherents\nare not signed and are not gossiped individually but rather only when they are included in a block.\nThe inherents in a block are assumed to be valid if a supermajority of validators assumes so.\nTransactions on the relay chain are mainly concerned with the operation of the relay chain and\nPolkadot protocol as a whole, such as set code, transfer, bond, validate, nominate, vote."),(0,o.kt)("p",null,"Relay chain block producers listen to all transaction network messages. Upon receiving a transaction\nmessage, the transaction(s) are validated by the Runtime. The valid transactions then are arranged\nin a queue based on their priority and dependency and are considered for inclusion in future blocks\naccordingly."),(0,o.kt)("h2",{id:"transaction-fees"},"Transaction Fees"),(0,o.kt)("p",null,"We use the model described above to set the fee level of a transaction based on three parameters:\nits type, its on-chain length, and its expected resource usage. This fee differentiation is used to\nreflect the different costs that a transaction incurs on the network and on the state, and to\nencourage the processing of certain types of transactions over others. A fraction of every\ntransaction fee is paid to the block producer, while another fraction goes to finance the Treasury.\nWe highlight that, for a block producer, the rewards coming from transaction fees may constitute\nonly a small fraction of their overall revenue, just enough to incentivise inclusion on the block.\nWe also run an adaptive transaction fee schedule that reacts to the traffic level, and ensures that\nblocks are typically far from full, so that peaks of activity can be dealt with effectively and long\ninclusion times are rare. In particular, the fee of each transaction is multiplied by a parameter\nthat evolves over time depending on the current network traffic. We make fees evolve slowly enough,\nso that the fee of any transaction can be predicted accu- rately within a frame of an hour. In\nparticular, we do not intend for transaction fees to be the main source of income for stakers."))}u.isMDXComponent=!0}}]);