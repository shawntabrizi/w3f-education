"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9125],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>y});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(a),b=i,y=h["".concat(s,".").concat(b)]||h[b]||u[b]||o;return a?n.createElement(y,r(r({ref:t},d),{},{components:a})):n.createElement(y,r({ref:t},d))}));function y(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=b;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}b.displayName="MDXCreateElement"},914:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(7462),i=(a(7294),a(3905));const o={id:"scalability"},r="Scalability",l={unversionedId:"Polkadot/Module5/scalability",id:"Polkadot/Module5/scalability",title:"Scalability",description:"Validity and Availability",source:"@site/docs/Polkadot/Module5/scalability.md",sourceDirName:"Polkadot/Module5",slug:"/Polkadot/Module5/scalability",permalink:"/docs/Polkadot/Module5/scalability",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module5/scalability.md",tags:[],version:"current",lastUpdatedBy:"D\xf3nal Murray",lastUpdatedAt:1692614373,formattedLastUpdatedAt:"Aug 21, 2023",frontMatter:{id:"scalability"},sidebar:"polkadot",previous:{title:"Parachains",permalink:"/docs/Polkadot/Module5/parachains"},next:{title:"Polkadot Architecture Improvements",permalink:"/docs/Polkadot/Module5/architectureimprovements"}},s={},c=[{value:"Validity and Availability",id:"validity-and-availability",level:2}],d={toc:c},h="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(h,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"scalability"},"Scalability"),(0,i.kt)("h2",{id:"validity-and-availability"},"Validity and Availability"),(0,i.kt)("p",null,"Once a parachain block is created it is important that the parachain blob consisting of the PoV\nblock and set of outgoing messages from the parachain is available for a while. The naive solution\nfor this would be broadcasting/gossip the parachain blobs to all relay chain nodes, which is not\na feasible option because there are many parachains and the PoV blocks may be big. We want\nto find an efficient solution to ensure PoV blocks from any recently created parachain blocks are\navailable."),(0,i.kt)("p",null,"For a single chain, such as Bitcoin, as long as 51% of hash power is honest, not making block data\navailable ensures that no honest miner builds on it so it will not be in the final chain. However,\nparachain consensus in Polkadot is determined by relay chain consensus. A parachain block is\ncanonical when its header is in the relay chain. We have no guarantees that anyone other than the\ncollator and parachain validators have seen the PoV block. If these collude then the rest of the\nparachain network need not have the parachain block and then most collators cannot build a new\nblock and this block's invalidity may not be discovered. We would like the consensus participants,\nhere the validators, to collectively guarantee the availability rather than relying on a few nodes.\nTo this end we designed an availability scheme that uses erasure coding  to\ndistribute the PoV block to all validators. When any misbehaviour, particularly in relation to\ninvalidity, is detected, the blob can be reconstructed from the distributed erasure coded pieces.\nIf a block is available then full nodes of the parachain, and any light client that has the PoV\nblock, can check its validity. We have three-level of validity checks in Polkadot. The first validity\ncheck of a PoV block is executed by the corresponding parachain validators. If they verify the\nPoV block then they sign and distribute the erasure codes of the blob, including the PoV block, to\neach validator. We rely on nodes acting as fishermen to report the invalidity of a blob as a second\nlevel of validity checking. They would need to back any claim with their own stake in DOTs. We\nwould assume that most collators will be fishermen, as they have a stake in continued validity of\nthe chain and are already running full nodes, so all they need is stake in DOTs. The third level of\nvalidity checking is executed by a few randomly and privately assigned validators. We determine\nthe number of validators in the third level of validity checking considering the amount of invalidity\nreports given by fishermen and unavailability reports given by collators. If an invalid parachain\nblock is detected, the validators who signed for its validity are slashed. We wait for enough of\nthese randomly assigned checkers to check the block before voting on it in GRANDPA. We also\nwant to ensure that the block is available before selecting the randomly assigned validators. This\nmeans that the parachain validators have to commit running a high risk of being slashed for a small\nprobability of getting an invalid block finalised. This means that the expected cost of getting an\ninvalid block into Polkadot is higher than the amount of stake backing a single parachain.\nThe security of our availability and validity scheme is based on the security of the GRANDPA\nfinality gadget and the quality of randomness generated in each BABE epoch."))}u.isMDXComponent=!0}}]);