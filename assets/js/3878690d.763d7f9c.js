"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[5137],{3905:function(e,t,a){a.d(t,{Zo:function(){return m},kt:function(){return d}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=u(a),d=i,h=c["".concat(s,".").concat(d)]||c[d]||p[d]||r;return a?n.createElement(h,l(l({ref:t},m),{},{components:a})):n.createElement(h,l({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=a[u];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},8327:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return s},default:function(){return c},frontMatter:function(){return o},metadata:function(){return u},toc:function(){return m}});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),l=["components"],o={id:"variables-mutability",title:"Variables & Mutability",sidebar_label:"Variables & Mutability",description:"How variables and mutability works in Rust."},s=void 0,u={unversionedId:"Rust/section2/variables-mutability",id:"Rust/section2/variables-mutability",isDocsHomePage:!1,title:"Variables & Mutability",description:"How variables and mutability works in Rust.",source:"@site/docs/Rust/section2/variables-mutability.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/variables-mutability",permalink:"/docs/Rust/section2/variables-mutability",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/variables-mutability.md",version:"current",lastUpdatedBy:"Radha",lastUpdatedAt:1682935333,formattedLastUpdatedAt:"5/1/2023",frontMatter:{id:"variables-mutability",title:"Variables & Mutability",sidebar_label:"Variables & Mutability",description:"How variables and mutability works in Rust."},sidebar:"rust",previous:{title:"Intro to Basic Rust",permalink:"/docs/Rust/section2/section-2-intro"},next:{title:"Data Types",permalink:"/docs/Rust/section2/data-types"}},m=[{value:"Immutability in Rust",id:"immutability-in-rust",children:[]},{value:"Shadowing in Rust",id:"shadowing-in-rust",children:[]},{value:"Constants in Rust",id:"constants-in-rust",children:[]},{value:"Try it out!",id:"try-it-out",children:[]},{value:"What is happening here?",id:"what-is-happening-here",children:[]}],p={toc:m};function c(e){var t=e.components,a=(0,i.Z)(e,l);return(0,r.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/eE5x17yRzUA",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share",allowfullscreen:!0}),(0,r.kt)("p",null,"If you have ever used another programming language, the concept of ",(0,r.kt)("strong",{parentName:"p"},"variables")," should be familiar. "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'// A couple Rust variables. \n// The first holds a name (a slice of text), and the other, an age (a number).\nlet my_name: &str = "Bader";\nlet age: u32 = 22;\n// We\'ll dive more into this line later, but just know that it is a way to print information.\nprintln!("My name is {my_name} and I am {age} years old.");\n')),(0,r.kt)("p",null,"As in other languages, variables in Rust behave mostly the same with the exception of a few unique properties, the most prominent being ",(0,r.kt)("strong",{parentName:"p"},"mutability")," and ",(0,r.kt)("strong",{parentName:"p"},"shadowing")," ."),(0,r.kt)("div",{className:"admonition admonition-info alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"All variables in Rust are immutable by default.  Immutable variables cannot be changed unless explicitly declared as mutable.  This prevents unwanted changes to values in code.  "))),(0,r.kt)("h2",{id:"immutability-in-rust"},"Immutability in Rust"),(0,r.kt)("p",null,"As mentioned before, by default, all variables in Rust are immutable.  This means that once a variable has been declared, the value within cannot be changed."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// The compiler won't allow this to be changed. \n// This code would throw an error!\n\nlet age: u32 = 22;\n// Increment the age by one.\nage += 1;\n\n======\n\nerror[E0384]: cannot assign twice to immutable variable `age`\n  --\x3e src/main.rs:26:1\n   |\n24 | let age: u32 = 22;\n   |     ---\n   |     |\n   |     first assignment to `age`\n   |     help: consider making this binding mutable: `mut age`\n25 | // Increment the age by one.\n26 | age += 1;\n   | ^^^^^^^^ cannot assign twice to an immutable variable\n")),(0,r.kt)("p",null,"This is yet another example of how the Rust compiler prevents any illegal operations, along with a descriptive way of letting the developer know.  The most interesting line to note is ",(0,r.kt)("inlineCode",{parentName:"p"},"cannot assign twice to immutable variable"),", as this clearly shows the immutability property of the variable."),(0,r.kt)("p",null,"This same error is actually incredibly useful, as in some cases, we sometimes want to keep the value of a variable the same.  The Rust compiler, by default, keeps this ",(0,r.kt)("em",{parentName:"p"},"safe")," by keeping it immutable.  There are many practical reasons for this, i.e., multi-developer projects, where one developer can see the program's intentions by whether a variable is mutable.  "),(0,r.kt)("p",null,"A variable's value changing unintentionally can also cause trivial bugs, but luckily the Rust compiler deals with it elegantly using immutability."),(0,r.kt)("p",null,"Of course, variables aren't always meant to be immutable.  To allow a variable to become mutable, use the ",(0,r.kt)("inlineCode",{parentName:"p"},"mut")," keyword before the variable name when declaring it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// This works now!  Notice the `mut`, short for mutable, after `let`\nlet mut age: u32 = 22;\n// Increment the age by one.\nage += 1;\n")),(0,r.kt)("h2",{id:"shadowing-in-rust"},"Shadowing in Rust"),(0,r.kt)("p",null,"Along with variability, Rust introduces the concept of ",(0,r.kt)("strong",{parentName:"p"},"shadowing"),".  Take a look at this example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'let x = 10u32;\nlet x: &str = "Hello!";\n\n// Prints "Hello!"\nprintln!("{x}");\n')),(0,r.kt)("p",null,"At first glance, this may seem odd - why are there two variables with the same name ",(0,r.kt)("em",{parentName:"p"},"and")," different type?  Shouldn't Rust's type system prevent this from occurring?"),(0,r.kt)("p",null,"This is what's called shadowing.  The Rust compiler will take the latest value assigned to that variable name, in this case from the number ",(0,r.kt)("inlineCode",{parentName:"p"},"10")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"Hello!"),", and utilize that until either the scope ends or it is shadowed again."),(0,r.kt)("p",null,"Shadowing is not the same as declaring a variable mutable with ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),", as it remains immutable after being shadowed.  The ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," keyword must also be used to shadow a variable, take a look at the following example: "),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet x = 10u32;\nx = "Hello!";\n\n')),(0,r.kt)("p",null,"The above code will fail to compile, as no new assignment is being made via ",(0,r.kt)("inlineCode",{parentName:"p"},"let"),".  It is trying, in essence, to assign a number of type ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," to a slice of text."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'\nCompiling playground v0.0.1 (/playground)\nerror[E0308]: mismatched types\n --\x3e src/main.rs:3:5\n  |\n2 | let x = 10u32;\n  |         ----- expected due to this value\n3 | x = "Hello!";\n  |     ^^^^^^^^ expected `u32`, found `&str`\n\n')),(0,r.kt)("p",null,"Shadowing with ",(0,r.kt)("inlineCode",{parentName:"p"},"let")," reassigns the variable to a new type and value, redefining it altogether."),(0,r.kt)("h2",{id:"constants-in-rust"},"Constants in Rust"),(0,r.kt)("p",null,"As with traditional, immutable variables in Rust, ",(0,r.kt)("strong",{parentName:"p"},"constants")," are also immutable - permanently.  Constants in Rust cannot be made into mutable variables with ",(0,r.kt)("inlineCode",{parentName:"p"},"mut"),".  Another difference is that constants only may be set to a constant expression, meaning the value is hardcoded and not calculated as the result of some function in runtime."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"\nconst THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;\n\n")),(0,r.kt)("p",null,"The naming convention for constants is all uppercase, with underscores between each word.  They can be used for declaring some standard, global, and constant variables within your Rust program."),(0,r.kt)("h2",{id:"try-it-out"},"Try it out!"),(0,r.kt)("p",null,"Try out some of these concepts yourself!  There are a few things that may seem unfamiliar here, which will be covered on the next page, however - have a look at the code and familiarize yourself:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"u32")," means that a variable is a number."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"&str")," means that the variable is a string literal.")),(0,r.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+%0Afn+main%28%29+%7B%0A%0A%2F%2F+We+start+by+creating+two+variables+-+one+is+mutable.%0A%2F%2F+In+the+context+of+this+program%2C+it+makes+sense+-+an+age+can+change%2C%0A%2F%2F+but+a+name+never+usually+changes.%0A%0Alet+mut+age%3A+%26str+%3D+%2222%22%3B%0Alet+name%3A+%26str+%3D+%22Bader%22%3B%0A%0Aprintln%21%28%22%7Bname%7D%3A+%7Bage%7D%22%29%3B%0A%0A%2F%2F+Seems+there+is+a+problem.+Notice+the+age+isnt%27+a+number%2C+but+a+string+of+text%21%0A%2F%2F+It%27s+rather+cumbersome+to+have+to+add+numbers+to+strings+-+not+to+mention+very+impractical.%0A%2F%2F+How+can+we+change+that%3F%0A%0A%2F%2F+To+turn+a+string+into+a+number%2C+we+can+use+the+following+syntax%3A+%0A%2F%2F+age.parse%28%29.unwrap%28%29%3B%0A%2F%2F+Write+a+variable+that+shadows+the+existing+%60age%60+variable+as+a+number.%0A%2F%2F+Make+sure+you+declare+it+as+mutable.%0A%2F%2F+Lastly%2C+add+one+to+it+to+increment+the+age+%28one+year+as+passed%21%29%0A%0Alet+mut+age%3A+u32+%3D+age.parse%28%29.unwrap%28%29%3B%0Aage+%2B%3D+1%3B%0Aprintln%21%28%22%7Bname%7D%3A+%7Bage%7D%22%29%3B%0A%0A%2F%2F+What+has+changed+here%3F+Hint%3A+Take+a+look+at+age+and+see%21%0A%0A%7D"}),(0,r.kt)("h2",{id:"what-is-happening-here"},"What is happening here?"),(0,r.kt)("p",null,"Three primary concepts are being put to use here - namely, ",(0,r.kt)("strong",{parentName:"p"},"immutability")," and ",(0,r.kt)("strong",{parentName:"p"},"shadowing"),".  Initially, we declare two variables - ",(0,r.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"age"),".  ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," is mutable, as age is expected to change, however, a name is meant to be immutable.  However, ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," is set to a type that we can't add to easily."),(0,r.kt)("p",null,"This is where shadowing comes into play.  Using shadowing, redefine ",(0,r.kt)("inlineCode",{parentName:"p"},"age")," to be a number of type ",(0,r.kt)("inlineCode",{parentName:"p"},"u32")," instead.  This allows us to add to the age easily."))}c.isMDXComponent=!0}}]);