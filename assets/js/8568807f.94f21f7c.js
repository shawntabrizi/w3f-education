"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9594],{3905:(e,t,o)=>{o.d(t,{Zo:()=>d,kt:()=>m});var n=o(7294);function i(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,n)}return o}function r(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){i(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function s(e,t){if(null==e)return{};var o,n,i=function(e,t){if(null==e)return{};var o,n,i={},a=Object.keys(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||(i[o]=e[o]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)o=a[n],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}var l=n.createContext({}),c=function(e){var t=n.useContext(l),o=t;return e&&(o="function"==typeof e?e(t):r(r({},t),e)),o},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var o=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(o),p=i,m=h["".concat(l,".").concat(p)]||h[p]||u[p]||a;return o?n.createElement(m,r(r({ref:t},d),{},{components:o})):n.createElement(m,r({ref:t},d))}));function m(e,t){var o=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=o.length,r=new Array(a);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<a;c++)r[c]=o[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,o)}p.displayName="MDXCreateElement"},7779:(e,t,o)=>{o.r(t),o.d(t,{contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=o(7462),i=(o(7294),o(3905));const a={id:"consensus"},r="Polkadot Network Consensus",s={unversionedId:"Polkadot/Module3/consensus",id:"Polkadot/Module3/consensus",isDocsHomePage:!1,title:"Polkadot Network Consensus",description:"We need to be able to revert the chain until we know with good probability",source:"@site/docs/Polkadot/Module3/consensus.md",sourceDirName:"Polkadot/Module3",slug:"/Polkadot/Module3/consensus",permalink:"/docs/Polkadot/Module3/consensus",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module3/consensus.md",version:"current",lastUpdatedBy:"Radha",lastUpdatedAt:1654881714,formattedLastUpdatedAt:"6/10/2022",frontMatter:{id:"consensus"},sidebar:"polkadot",previous:{title:"Treasury",permalink:"/docs/Polkadot/Module2/treasury"},next:{title:"Nominated Proof of Staking",permalink:"/docs/Polkadot/Module3/npos"}},l=[{value:"BABE",id:"babe",children:[{value:"Relative Time Protocol",id:"relative-time-protocol",children:[]}]},{value:"GRANDPA Finality Gadget",id:"grandpa-finality-gadget",children:[]}],c={toc:l},d="wrapper";function h(e){let{components:t,...o}=e;return(0,i.kt)(d,(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"polkadot-network-consensus"},"Polkadot Network Consensus"),(0,i.kt)("p",null,"We need to be able to revert the chain until we know with good probability\nthat all parachains are correct. This means that we need to be able to reorganise the chain and\nfor that the chain needs to be capable of forking. Thus we use a block production mechanism,\nBABE, that while run by validators, has similar properties to proof-of-work chains.\nSpeci\u2000cally, we can use the longest chain rule as part of our consensus, and the next block producer\nis not known in advance. On its own BABE would require us to wait a long time from the moment\na block is produced to the moment it is finalised, i.e. when we can be confident that with high\nprobability the block will never be reverted. Slow \u2000finality is required in some circumstances to\ndeal with challenges to availability. Most of the time, however, we would prefer to finalise blocks\nmuch faster. For this purpose, validators \u2000nalise blocks using GRANDPA, a finality\ngadget that is cleanly separated from block production. This separation makes it very adaptive\nand here allows us to delay finalising blocks until challenges are dealt with, without slowing down\nblock production. GRANDPA gets Byzantine agreement on finalised blocks and will allow us to\nprove to an entity that keeps track of the validator set which blocks are finalised, which will be\nimportant for bridges."),(0,i.kt)("h2",{id:"babe"},"BABE"),(0,i.kt)("p",null,'In Polkadot, we produce relay chain blocks using our Blind Assignment for Blockchain Extension\nprotocol (BABE). BABE assigns validators randomly to block production slots using the random-\nness generated with blocks. A block production slot is a division of time when a block producer may\nproduce a block. Note, that time is not universally agreed on, which we will address later. These\nassignments are completely private until the assigned validators produce their blocks. Therefore,\nwe use \\Blind Assignment" in the protocol name. BABE is similar to Ouroboros Praos with\nsome significant differences in the chain selection rule and timing assumptions.\nIn BABE, we may have slots without any assignment which we call empty slot. In order to \u2000ll\nthe empty slots, we have a secondary block production mechanism based on Aura that assigns\nvalidators to slots publicly. We note that these blocks do not contribute to the security of BABE\nsince the best chain selection and the random number generation algorithms work as if Aura blocks\ndo not exist. Therefore, next we only describe BABE together with its security properties.'),(0,i.kt)("h3",{id:"relative-time-protocol"},"Relative Time Protocol"),(0,i.kt)("p",null,"Relative Time Protocol: The elected validators for a slot need to know when the right time\nis to produce a block for the consistency and the security of BABE. For this, validators uses their\nlocal computer clock which is not adjusted by any centralized clock adjustment protocols such\nas the Network Time Protocol. Instead, they keep their clock synchronised with the other\nvalidators with the relative time protocol. "),(0,i.kt)("p",null,"In BABE, we assume that after the genesis block is released, elected validators of the \u2000rst epoch\nstore the arrival time of the genesis block with respect to their local clock. Then, they mark the\nbeginning time of the \u2000rst slot and increment the slot number every T seconds. After this point,\nthey periodically run the relative algorithm not to lose the synchronisation with others because of\ntheir local clock drifts. In addition to this, a validator who joins after the genesis block runs the\nrelative time algorithm to be synchronised with the other validators."),(0,i.kt)("p",null,"As mentioned above, we want a \u2000nalisation mechanism that is\nexible and separated from block\nproduction, which is achieved by GRANDPA. The only modi\u2000cation to BABE required for it to\nwork with GRANDPA is to change the fork-choice rule: instead of building on the longest chain,\na validator producing a block should build on the longest chain including all blocks that it sees as\n\u2000nalised. GRANDPA can work with many di\u2000erent block production mechanisms and it will be\npossible to switch out BABE with another.\nIntuitively GRANDPA is a Byzantine agreement protocol that works to agree on a chain,\nout of many possible forks, by following some simpler fork choice rule, which together with the\nblock production mechanism would give probabilistic \u2000nality if GRANDPA itself stopped \u2000nalising\nblocks. We want to be able to agree on many blocks at once, in contrast to single-block Byzantine\nagreement protocols.\nWe assume that we can ask the fork choice rule for the best block given a particular block. The\nbasic idea is that we want to reach Byzantine agreement on the pre\u2000x of the chain that everyone\nagrees on. To make this more robust, we try to agree on the pre\u2000x of the chain that 2/3 of\nvalidators agree on."),(0,i.kt)("h2",{id:"grandpa-finality-gadget"},"GRANDPA Finality Gadget"),(0,i.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/0shPS6SXPKE",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))}h.isMDXComponent=!0}}]);