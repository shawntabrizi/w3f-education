"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9125],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>y});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},b=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(a),b=i,y=h["".concat(s,".").concat(b)]||h[b]||u[b]||o;return a?n.createElement(y,r(r({ref:t},d),{},{components:a})):n.createElement(y,r({ref:t},d))}));function y(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=a.length,r=new Array(o);r[0]=b;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[h]="string"==typeof e?e:i,r[1]=l;for(var c=2;c<o;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}b.displayName="MDXCreateElement"},90914:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>c});var n=a(87462),i=(a(67294),a(3905));const o={id:"scalability"},r="Scalability",l={unversionedId:"Polkadot/Module5/scalability",id:"Polkadot/Module5/scalability",title:"Scalability",description:"Validity and Availability",source:"@site/docs/Polkadot/Module5/scalability.md",sourceDirName:"Polkadot/Module5",slug:"/Polkadot/Module5/scalability",permalink:"/docs/Polkadot/Module5/scalability",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module5/scalability.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"scalability"},sidebar:"polkadot",previous:{title:"Parachains",permalink:"/docs/Polkadot/Module5/parachains"},next:{title:"Polkadot Architecture Improvements",permalink:"/docs/Polkadot/Module5/architectureimprovements"}},s={},c=[{value:"Validity and Availability",id:"validity-and-availability",level:2}],d={toc:c},h="wrapper";function u(e){let{components:t,...a}=e;return(0,i.kt)(h,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"scalability"},"Scalability"),(0,i.kt)("h2",{id:"validity-and-availability"},"Validity and Availability"),(0,i.kt)("p",null,"Once a parachain block is created it is important that the parachain blob consisting of the PoV\nblock and set of outgoing messages from the parachain is available for a while. The naive solution\nfor this would be broadcasting/gossip the parachain blobs to all relay chain nodes, which is not a\nfeasible option because there are many parachains and the PoV blocks may be big. We want to find an\nefficient solution to ensure PoV blocks from any recently created parachain blocks are available."),(0,i.kt)("p",null,"For a single chain, such as Bitcoin, as long as 51% of hash power is honest, not making block data\navailable ensures that no honest miner builds on it so it will not be in the final chain. However,\nparachain consensus in Polkadot is determined by relay chain consensus. A parachain block is\ncanonical when its header is in the relay chain. We have no guarantees that anyone other than the\ncollator and parachain validators have seen the PoV block. If these collude then the rest of the\nparachain network need not have the parachain block and then most collators cannot build a new block\nand this block's invalidity may not be discovered. We would like the consensus participants, here\nthe validators, to collectively guarantee the availability rather than relying on a few nodes. To\nthis end we designed an availability scheme that uses erasure coding to distribute the PoV block to\nall validators. When any misbehaviour, particularly in relation to invalidity, is detected, the blob\ncan be reconstructed from the distributed erasure coded pieces. If a block is available then full\nnodes of the parachain, and any light client that has the PoV block, can check its validity. We have\nthree-level of validity checks in Polkadot. The first validity check of a PoV block is executed by\nthe corresponding parachain validators. If they verify the PoV block then they sign and distribute\nthe erasure codes of the blob, including the PoV block, to each validator. We rely on nodes acting\nas fishermen to report the invalidity of a blob as a second level of validity checking. They would\nneed to back any claim with their own stake in DOTs. We would assume that most collators will be\nfishermen, as they have a stake in continued validity of the chain and are already running full\nnodes, so all they need is stake in DOTs. The third level of validity checking is executed by a few\nrandomly and privately assigned validators. We determine the number of validators in the third level\nof validity checking considering the amount of invalidity reports given by fishermen and\nunavailability reports given by collators. If an invalid parachain block is detected, the validators\nwho signed for its validity are slashed. We wait for enough of these randomly assigned checkers to\ncheck the block before voting on it in GRANDPA. We also want to ensure that the block is available\nbefore selecting the randomly assigned validators. This means that the parachain validators have to\ncommit running a high risk of being slashed for a small probability of getting an invalid block\nfinalised. This means that the expected cost of getting an invalid block into Polkadot is higher\nthan the amount of stake backing a single parachain. The security of our availability and validity\nscheme is based on the security of the GRANDPA finality gadget and the quality of randomness\ngenerated in each BABE epoch."))}u.isMDXComponent=!0}}]);