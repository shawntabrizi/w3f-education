"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[8187],{3905:(t,e,o)=>{o.d(e,{Zo:()=>p,kt:()=>h});var r=o(7294);function a(t,e,o){return e in t?Object.defineProperty(t,e,{value:o,enumerable:!0,configurable:!0,writable:!0}):t[e]=o,t}function n(t,e){var o=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),o.push.apply(o,r)}return o}function l(t){for(var e=1;e<arguments.length;e++){var o=null!=arguments[e]?arguments[e]:{};e%2?n(Object(o),!0).forEach((function(e){a(t,e,o[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(o)):n(Object(o)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(o,e))}))}return t}function i(t,e){if(null==t)return{};var o,r,a=function(t,e){if(null==t)return{};var o,r,a={},n=Object.keys(t);for(r=0;r<n.length;r++)o=n[r],e.indexOf(o)>=0||(a[o]=t[o]);return a}(t,e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);for(r=0;r<n.length;r++)o=n[r],e.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(t,o)&&(a[o]=t[o])}return a}var c=r.createContext({}),s=function(t){var e=r.useContext(c),o=e;return t&&(o="function"==typeof t?t(e):l(l({},e),t)),o},p=function(t){var e=s(t.components);return r.createElement(c.Provider,{value:e},t.children)},u="mdxType",d={inlineCode:"code",wrapper:function(t){var e=t.children;return r.createElement(r.Fragment,{},e)}},f=r.forwardRef((function(t,e){var o=t.components,a=t.mdxType,n=t.originalType,c=t.parentName,p=i(t,["components","mdxType","originalType","parentName"]),u=s(o),f=a,h=u["".concat(c,".").concat(f)]||u[f]||d[f]||n;return o?r.createElement(h,l(l({ref:e},p),{},{components:o})):r.createElement(h,l({ref:e},p))}));function h(t,e){var o=arguments,a=e&&e.mdxType;if("string"==typeof t||a){var n=o.length,l=new Array(n);l[0]=f;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i[u]="string"==typeof t?t:a,l[1]=i;for(var s=2;s<n;s++)l[s]=o[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,o)}f.displayName="MDXCreateElement"},4106:(t,e,o)=>{o.r(e),o.d(e,{assets:()=>c,contentTitle:()=>l,default:()=>d,frontMatter:()=>n,metadata:()=>i,toc:()=>s});var r=o(7462),a=(o(7294),o(3905));const n={id:"collator",title:"C for Collator",sidebar_position:3},l=void 0,i={unversionedId:"AtoZ/collator",id:"AtoZ/collator",title:"C for Collator",description:"C for Collators",source:"@site/docs/AtoZ/collator.md",sourceDirName:"AtoZ",slug:"/AtoZ/collator",permalink:"/docs/AtoZ/collator",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/AtoZ/collator.md",tags:[],version:"current",lastUpdatedBy:"Filippo",lastUpdatedAt:1676642198,formattedLastUpdatedAt:"Feb 17, 2023",sidebarPosition:3,frontMatter:{id:"collator",title:"C for Collator",sidebar_position:3},sidebar:"atoz",previous:{title:"B for Bridge",permalink:"/docs/AtoZ/bridge"},next:{title:"D for Democracy",permalink:"/docs/AtoZ/democracy"}},c={},s=[],p={toc:s},u="wrapper";function d(t){let{components:e,...n}=t;return(0,a.kt)(u,(0,r.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"C for Collators",src:o(2951).Z,width:"800",height:"420"})),(0,a.kt)("p",null,"Collate (verb):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To examine and compare carefully to note points of disagreement."),(0,a.kt)("li",{parentName:"ul"},"To assemble in proper numerical or logical sequence.")),(0,a.kt)("p",null,"Collators are the maintainers of Parachains, which we will cover in more detail when we get to letter P. As a node on the network they have an important task, and that is to keep track of both the state of the Polkadot relay chain as well as maintain the state of the given Parachain that they run on. They do this by running a full node of the relay chain and a full node of the parachain and then building parachain blocks along with a proof of validity for those blocks, which gets proposed to the Polkadot relay chain validators. Once a block is proposed, they cannot start working on the next block until the relay chain validators accept the validity of the proposed block.\nUsing Cross-chain message passing(XCMP), which will be covered in letter X, Collators can communicate with other Collators of different parachains. This is imperative for allowing multi chain applications to work seamlessly.\nIf you\u2019re curious about how the technical details of Collators work, check out Cumulous, a set of tools created by Parity to build Polkadot parachains. "),(0,a.kt)("p",null,"Workshop/tutorial: ",(0,a.kt)("a",{parentName:"p",href:"https://substrate.dev/cumulus-workshop/#/"},"https://substrate.dev/cumulus-workshop/#/"),(0,a.kt)("br",{parentName:"p"}),"\n","Cumulus code: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/paritytech/cumulus/"},"https://github.com/paritytech/cumulus/"),"."))}d.isMDXComponent=!0},2951:(t,e,o)=>{o.d(e,{Z:()=>r});const r=o.p+"assets/images/C-c20d0ec38f6d46ee0f2482cfcbd244c8.png"}}]);