"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[1004],{3905:(e,a,t)=>{t.d(a,{Zo:()=>h,kt:()=>f});var o=t(67294);function n(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function i(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);a&&(o=o.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?i(Object(t),!0).forEach((function(a){n(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,o,n=function(e,a){if(null==e)return{};var t,o,n={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var s=o.createContext({}),c=function(e){var a=o.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):r(r({},a),e)),t},h=function(e){var a=c(e.components);return o.createElement(s.Provider,{value:a},e.children)},d="mdxType",p={inlineCode:"code",wrapper:function(e){var a=e.children;return o.createElement(o.Fragment,{},a)}},u=o.forwardRef((function(e,a){var t=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),d=c(t),u=n,f=d["".concat(s,".").concat(u)]||d[u]||p[u]||i;return t?o.createElement(f,r(r({ref:a},h),{},{components:t})):o.createElement(f,r({ref:a},h))}));function f(e,a){var t=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var i=t.length,r=new Array(i);r[0]=u;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l[d]="string"==typeof e?e:n,r[1]=l;for(var c=2;c<i;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}u.displayName="MDXCreateElement"},38870:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>r,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var o=t(87462),n=(t(67294),t(3905));const i={id:"parachainblock"},r="Path of a Parachain Block",l={unversionedId:"Polkadot/Module4/parachainblock",id:"Polkadot/Module4/parachainblock",title:"Path of a Parachain Block",description:"Collators watch the progress of the block-producing and consensus protocols, e.g. by participating",source:"@site/docs/Polkadot/Module4/parachainblock.md",sourceDirName:"Polkadot/Module4",slug:"/Polkadot/Module4/parachainblock",permalink:"/docs/Polkadot/Module4/parachainblock",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module4/parachainblock.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"parachainblock"},sidebar:"polkadot",previous:{title:"Nodes on Polkadot Network",permalink:"/docs/Polkadot/Module4/nodes"},next:{title:"Decentralization of Network",permalink:"/docs/Polkadot/Module4/decentralization"}},s={},c=[{value:"Parachains in Action",id:"parachains-in-action",level:2}],h={toc:c},d="wrapper";function p(e){let{components:a,...t}=e;return(0,n.kt)(d,(0,o.Z)({},h,t,{components:a,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"path-of-a-parachain-block"},"Path of a Parachain Block"),(0,n.kt)("p",null,"Collators watch the progress of the block-producing and consensus protocols, e.g. by participating\nin the relay chain as a full node. Based on what they think is the latest relay chain block that\nwill most likely be finalised, they build on top of the latest parachain block (or other data) that\nwould be finalised by it."),(0,n.kt)("p",null,"Collators sign data building on top of said latest parachain block, and submit it possibly\nindirectly, to the validators assigned to their parachain (parachain validators for short), for\ninclusion in the relay chain. Ideally they submit a unique one, to help performance."),(0,n.kt)("p",null,"The parachain validators decide which parachain block to support, and presents relevant data of it\nas a parachain's next candidate to be added to the next relay chain block."),(0,n.kt)("p",null,"A block-producing validator collects candidates from all parachains, and puts this collection along\nwith any recent relay chain extrinsics into a relay chain head block. For performance, this does not\ncontain the full data from all parachains, but only metadata and partial data, including\nsecurity-related metadata."),(0,n.kt)("p",null,"In the unfavourable case, this can result in forks, resolved later. This subprotocol is designed so\nthat even with forks, participants have an idea of the block most likely to be finalised, similar to\nProof-of-Work protocols."),(0,n.kt)("p",null,"A subprotocol is run to ensure that the full data is indeed available, including and distributing it\nto various other relay-chain nodes."),(0,n.kt)("p",null,"Data submitted from a parachain might include indications that they are sending messages to another\nparachain, including metadata to facilitate this. This is now included on the relay chain head(s),\nso recipient parachains are aware of which new messages have been sent to them. They now retrieve\nthe message bodies from the sending parachains."),(0,n.kt)("p",null,"Validators submit their votes on the block and finalises it, resolving any forks to a single head.\nThese votes are added to the relay chain blocks."),(0,n.kt)("h2",{id:"parachains-in-action"},"Parachains in Action"),(0,n.kt)("p",null,"In outline, a collator produces a parachain block, sends it to the parachain validators, who sign\nits header as valid, and the header with enough signatures is placed on the relay chain. At this\npoint, the parachain block is as canonical as the relay chain block its header appeared in. If this\nrelay chain block is in the best chain according to BABE, so is the parachain block and when this\nrelay chain block is finalised, so is the parachain block. Because the parachain validators switch\nparachains frequently, they are stateless clients of the parachain. Thus we distinguish between the\nparachain block B, which is normally enough for full nodes of the parachain such as collators to\nupdate the parachain state, and the Proof of Validity(PoV) block BPoV , which a validator who does\nnot have the parachain state can verify. Any validator should be able to verify BPoV given the relay\nchain state using the parachain's parachain validation function (PVF), the Web assembly code for\nwhich is stored on the relay chain in a similar way to the relay chain's runtime. The STVF takes as\nan input the PoV block, the header of the last parachain block from this parachain and a small\namount of data from the relay chain state. The STVF outputs the validity of the block, the header of\nthis block and its outgoing mes- sages. The PoV block contains any outgoing messages and the\nparachain block B. The parachain validators should gossip the parachain block to the parachain\nnetwork, as a back up to the collator itself doing so. The PoV block will be the parachain block,\nits outgoing messages, its header and light client proof witnesses. These witnesses are Merkle\nproofs that give all elements of the input and output state that are used or modified by the state\ntransition from the input and output state roots. To aid in censorship resistance, a parachain may\nwant to use proof of work or proof of stake to select collators, where the selection strategy is up\nto the given parachain. This can be implemented in the STVF and need not be a part of the Polkadot\nprotocol. So for proof of work, the STVF would check that the hash of the block is sufficiently\nsmall. However, for speed, it would be useful to ensure that most relay chain blocks can include a\nparachain block. For PoW, this would necessitate it being probable that multiple collators are\nallowed to produce a block. As such we will still need a tie-breaker for the parachain validators to\ncoordinate on validating the same parachain block first. This may be the golden ticket scheme of.\nFor proof of stake this may not be necessary."),(0,n.kt)("iframe",{width:"560",height:"315",src:"https://www.youtube.com/embed/AlnjFIfwOH0",title:"YouTube video player",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))}p.isMDXComponent=!0}}]);