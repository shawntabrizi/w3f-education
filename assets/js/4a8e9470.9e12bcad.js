"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[9168],{3905:function(e,t,a){a.d(t,{Zo:function(){return h},kt:function(){return m}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},h=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=l(a),d=r,m=u["".concat(c,".").concat(d)]||u[d]||p[d]||o;return a?n.createElement(m,i(i({ref:t},h),{},{components:a})):n.createElement(m,i({ref:t},h))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[u]="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},2828:function(e,t,a){a.r(t),a.d(t,{contentTitle:function(){return c},default:function(){return d},frontMatter:function(){return s},metadata:function(){return l},toc:function(){return h}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],s={id:"heap-vs-stack",title:"The Heap vs. The Stack",sidebar_label:"The Heap vs. The Stack",description:"Learn the summarized differences between the stack and the heap and how they affect your Rust programming."},c=void 0,l={unversionedId:"Rust/section2/heap-vs-stack",id:"Rust/section2/heap-vs-stack",isDocsHomePage:!1,title:"The Heap vs. The Stack",description:"Learn the summarized differences between the stack and the heap and how they affect your Rust programming.",source:"@site/docs/Rust/section2/heap-vs-stack.md",sourceDirName:"Rust/section2",slug:"/Rust/section2/heap-vs-stack",permalink:"/docs/Rust/section2/heap-vs-stack",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section2/heap-vs-stack.md",version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1685719113,formattedLastUpdatedAt:"6/2/2023",frontMatter:{id:"heap-vs-stack",title:"The Heap vs. The Stack",sidebar_label:"The Heap vs. The Stack",description:"Learn the summarized differences between the stack and the heap and how they affect your Rust programming."},sidebar:"rust",previous:{title:"Variables & Mutability",permalink:"/docs/Rust/section2/variables-mutability"},next:{title:"Data Types",permalink:"/docs/Rust/section2/data-types"}},h=[{value:"What do the stack and heap represent?",id:"what-do-the-stack-and-heap-represent",children:[]},{value:"The Stack",id:"the-stack",children:[]},{value:"The Heap",id:"the-heap",children:[]},{value:"When to use which?  How is this used in Rust?",id:"when-to-use-which--how-is-this-used-in-rust",children:[]}],u={toc:h},p="wrapper";function d(e){var t=e.components,a=(0,r.Z)(e,i);return(0,o.kt)(p,(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,'Throughout this course, a common occurrence presented is the notion of "putting" variables on either the ',(0,o.kt)("strong",{parentName:"p"},"stack")," or the ",(0,o.kt)("strong",{parentName:"p"},"heap"),".  This page provides a summary as to what each is and how they relate to programming in Rust.  Low-level languages have to be concerned with memory management and allocation.  This concept should be familiar if you're coming from a language like C or C++.  "),(0,o.kt)("h2",{id:"what-do-the-stack-and-heap-represent"},"What do the stack and heap represent?"),(0,o.kt)("p",null,"The stack and heap are memory management and allocation concepts.  They relate to how memory in any program is managed, accessed and whether or not it can be changed in the runtime.  The stack and heap are two common methods to accomplish a program's memory management and allocation."),(0,o.kt)("h2",{id:"the-stack"},"The Stack"),(0,o.kt)("p",null,'The stack is a linear model of storing objects on a "stack."  It is faster than the heap but cannot be modified as easily.  Objects are pushed and popped to and from the stack accordingly.  In Rust, items that are of known size are stored on the stack.  Known size in this context refers to some value that can be calculated at compile time, for example: '),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'let hello = "Hello, World";\n// or\nlet x = 10;\n')),(0,o.kt)("p",null,"Both ",(0,o.kt)("inlineCode",{parentName:"p"},"hello")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"x")," are pushed onto the stack because they are known in size, meaning their memory profile can be determined at compile time because their contents are defined preemptively.  "),(0,o.kt)("p",null,"In Rust, the stack is the default for managing primitive/basic values, call frames and local variables.  Non-primitives can also be put on the stack, but this is dependent on their lifetime and usage (i.e., a ",(0,o.kt)("inlineCode",{parentName:"p"},"struct")," that has elements of known size).  The stack itself also has a limited size, hence why the stack can overflow if too much memory is allocated to it."),(0,o.kt)("h2",{id:"the-heap"},"The Heap"),(0,o.kt)("p",null,"The heap refers to a dynamically managed, hierarchical model of storing objects.  It is slower than the stack but provides a way to store larger amounts of data for modification at a later time in memory.  Objects stored on the heap are typically not known in size at compile time, meaning they have the potential to grow and shrink as needed.  Rust has many mechanisms to manage this memory safely and avoid problems such as data races or dangling pointers."),(0,o.kt)("p",null,"In Rust, data structures such as ",(0,o.kt)("inlineCode",{parentName:"p"},"Vec")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"String")," utilize the heap, which can grow and shrink within the runtime."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-rust"},'// A vector in Rust, the Rust equivalent to an array\nlet vector_of_numbers = vec![0, 1, 2];\n// Change this in the runtime!\nmodify_vec(vector_of_numbers); // [0, 1, 2, 3]\n\n// A growable, shrinkable "String."\nlet hello_string = String::from("Hello, World");\nhello_string.push(\'!\'); // Adds an ! to hello_string\n')),(0,o.kt)("h2",{id:"when-to-use-which--how-is-this-used-in-rust"},"When to use which?  How is this used in Rust?"),(0,o.kt)("p",null,"In Rust, this memory management and allocation is handled for you. There is no special syntax to dictate this in Rust, as it is already a part of the language.  As you progress, you will learn how Rust efficiently manages memory through the ownership and borrowing systems while providing low-level access."))}d.isMDXComponent=!0}}]);