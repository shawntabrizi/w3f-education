"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[3369],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>y});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),h=c(n),p=r,y=h["".concat(l,".").concat(p)]||h[p]||u[p]||o;return n?a.createElement(y,i(i({ref:t},d),{},{components:n})):a.createElement(y,i({ref:t},d))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[h]="string"==typeof e?e:r,i[1]=s;for(var c=2;c<o;c++)i[c]=n[c];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},4558:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const o={id:"interoperability"},i="Interoperability",s={unversionedId:"Polkadot/Module5/interoperability",id:"Polkadot/Module5/interoperability",title:"Interoperability",description:"XCMP",source:"@site/docs/Polkadot/Module5/interoperability.md",sourceDirName:"Polkadot/Module5",slug:"/Polkadot/Module5/interoperability",permalink:"/docs/Polkadot/Module5/interoperability",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module5/interoperability.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"interoperability"},sidebar:"polkadot",previous:{title:"Decentralization of Network",permalink:"/docs/Polkadot/Module4/decentralization"},next:{title:"Polkadot Bridges",permalink:"/docs/Polkadot/Module5/bridges"}},l={},c=[{value:"XCMP",id:"xcmp",level:2}],d={toc:c},h="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(h,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"interoperability"},"Interoperability"),(0,r.kt)("h2",{id:"xcmp"},"XCMP"),(0,r.kt)("p",null,"If an account on one parachain sends tokens to another parachain, then XCMP ensures that this\nmessage is delivered correctly. It is sent at a speed which is not dependent on how long it takes to\nfinalise blocks, which means that it needs to deal with the possibility of Polkadot forking. Thus we\noptimistically execute based on the assumption that the parachain blocks are correct. If one is not,\nthen we need to revert and for that, it is important that parachains only receive messages that were\nsent by blocks recorded on this new relay chain fork, and not the reverted fork. Thus we need that\nthe parachain and XCMP logic ensure that a fork of the relay chain defines a consistent history of\nPolkadot and thus messages only arrive when they have been sent previously in the history defined by\nthis fork."),(0,r.kt)("p",null,"XCMP is the protocol that parachains use to send messages to each other. It aims to guarantee four\nthings: first that messages arrive quickly; second that messages from one parachain arrive to\nanother in order; third that arriving messages were indeed sent in the finalised history of the\nsending chain; and fourth that recipients will receive messages fairly across senders, helping\nguarantee that senders never wait indefinitely for their messages to be seen. There are two parts to\nXCMP. (1) Metadata about outgoing messages for a parachain block are included on the relay chain and\nlater this metadata is used to authenticate messages by the receiving parachain. (2) The message\nbodies corresponding to this metadata need to be actually distributed from the senders to the\nrecipients, together with a proof that the message body is actu- ally associated with the relevant\nmetadata. The details of distribution are covered as a networking protocol in Cross-chain message;\nthe remainder is covered below. The way relay chain blocks include headers of parachain blocks gives\na synchronous notion of time for parachain blocks, just by relay chain block numbers. Additionally\nit allows us to authenticate messages as being sent in the history given by the relay chain i.e. it\nis impossible that one parachain sends a message, then reorgs 2 so that that message was not sent,\nbut has been received. This holds even though the system may not have reached finality over whether\nthe message was sent, because any relay chain provides a consistent history. Because we require\nparachains to act on every message eventually, non-delivery of a single message can potentially stop\na parachain from being able to build blocks. Consequently we need enough redundancy in our message\ndelivery system. Any validators who validate the PoV block should keep any outgoing messages from\nthat block available for a day or so and all full nodes of the sending parachain also store the\noutgoing messages until they know they have been acted on."))}u.isMDXComponent=!0}}]);