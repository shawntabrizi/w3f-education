"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[4937],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var o=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},s=Object.keys(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(o=0;o<s.length;o++)n=s[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),l=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=l(e.components);return o.createElement(c.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},y=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(n),y=r,h=p["".concat(c,".").concat(y)]||p[y]||d[y]||s;return n?o.createElement(h,a(a({ref:t},u),{},{components:n})):o.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,a=new Array(s);a[0]=y;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[p]="string"==typeof e?e:r,a[1]=i;for(var l=2;l<s;l++)a[l]=n[l];return o.createElement.apply(null,a)}return o.createElement.apply(null,n)}y.displayName="MDXCreateElement"},9810:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var o=n(7462),r=(n(7294),n(3905));const s={id:"cryptography"},a="Cryptography",i={unversionedId:"Polkadot/Module4/cryptography",id:"Polkadot/Module4/cryptography",title:"Cryptography",description:"We assume that malicious parties generate their keys with an arbitrary algorithm while honest ones",source:"@site/docs/Polkadot/Module4/cryptography.md",sourceDirName:"Polkadot/Module4",slug:"/Polkadot/Module4/cryptography",permalink:"/docs/Polkadot/Module4/cryptography",draft:!1,editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Polkadot/Module4/cryptography.md",tags:[],version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1693238811,formattedLastUpdatedAt:"Aug 28, 2023",frontMatter:{id:"cryptography"},sidebar:"polkadot",previous:{title:"Security and Consensus Improvements",permalink:"/docs/Polkadot/Module3/securityimprovements"},next:{title:"Networking",permalink:"/docs/Polkadot/Module4/networking"}},c={},l=[{value:"Account Keys",id:"account-keys",level:2},{value:"Session Keys",id:"session-keys",level:2}],u={toc:l},p="wrapper";function d(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,o.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cryptography"},"Cryptography"),(0,r.kt)("p",null,"We assume that malicious parties generate their keys with an arbitrary algorithm while honest ones\nalways generate their keys securely."),(0,r.kt)("p",null,"In Polkadot, we necessarily distinguish among different permissions and functionalities with dif-\nferent keys and key types, respectively. We roughly categorise these into account keys with which\nusers interact and session keys that nodes manage without operator intervention beyond a\ncertificcation process."),(0,r.kt)("h2",{id:"account-keys"},"Account Keys"),(0,r.kt)("p",null,"Account keys have an associated balance of which portions can be locked to play roles in staking,\nresource rental, and governance, including waiting out a couple types of unlocking period. We allow\nseveral locks of varying duration, both because these roles impose different restrictions, and for\nmultiple unlocking periods running concurrently. We encourage active participation in all these\nroles, but they all require occasional signatures from accounts. At the same time, account keys have\nbetter physical security when kept in incon- venient locations, like safety deposit boxes, which\nmakes signing arduous. We avoid this friction for users as follows. Accounts that lock funds for\nstaking are called stash accounts. All stash accounts register a certificate on-chain that delegates\nall validator operation and nomination powers to some controller account, and also designates some\nproxy key for governance votes. In this state, the controller and proxy accounts can sign for the\nstash account in staking and governance functions respectively, but not transfer funds. At present,\nwe support both ed25519 and Schnorrkel/sr25519 for account keys. These are both Schnorr-like\nsignatures implemented using the Ed25519 curve, so both offer extremely similar security. We\nrecommend ed25519 keys for users who require Hardware Security Module (HSM) support or other\nexternal key management solution, while Schnorrkel/sr25519 provides more blockchain-friendly\nfunctionality like Hierarchical Deterministic Key Derivation (HDKD) and multi-signatures. In\nparticular, Schnorrkel/sr25519 uses the Ristretto implementation of Mike Hamburg's Decaf, which\nprovide the 2-torsion free points of the Ed25519 curve as a prime order group. Avoiding the cofactor\nlike this means Ristretto makes implementing more complex pro- tocols significantly safer. We employ\nBlake2b for most conventional hashing in Polkadot, but Schnorrkel/sr25519 itself uses STROBE128,\nwhich is based on Keccak-f(1600) and provides a hashing interface well suited to signatures and\nnon-interactive zero-knowledge proofs (NIZKs)."),(0,r.kt)("h2",{id:"session-keys"},"Session Keys"),(0,r.kt)("p",null,"Session keys each fill roughly one particular role in consensus or security. As a rule, session keys\ngain authority only from a session certificate, signed by some controller key, that delegates\nappropriate stake. At any time, the controller key can pause or revoke this session certificate\nand/or issue re- placement with new session keys. All new session keys can be registered in advance,\nand most must be, so validators can cleanly transition to new hardware by issuing session\ncertificates that only become valid after some future session. We suggest using pause mechanism for\nemergency maintenance and using revocation if a session key might be compromised. We prefer if\nsession keys remain tied to one physical machine because doing so minimises the risk of accidental\nequivocation. We ask validator operators to issue session certificates using an RPC protocol, not to\nhandle the session secret keys themselves. Almost all early proof-of-stake networks have a negligent\npublic key infrastructure that en- courages duplicating session secret keys across machines, and\nthus reduces security and leads to pointless slashing. We impose no prior restrictions on the\ncryptography employed by specific components or their associated session keys types"))}d.isMDXComponent=!0}}]);