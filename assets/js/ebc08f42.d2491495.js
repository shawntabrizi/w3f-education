"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[4690],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),l=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=l(e.components);return a.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,u=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=l(n),h=r,f=d["".concat(u,".").concat(h)]||d[h]||p[h]||s;return n?a.createElement(f,i(i({ref:t},c),{},{components:n})):a.createElement(f,i({ref:t},c))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},2345:function(e,t,n){n.r(t),n.d(t,{contentTitle:function(){return u},default:function(){return d},frontMatter:function(){return o},metadata:function(){return l},toc:function(){return c}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),i=["components"],o={id:"structs",title:"Data Structs in rust",sidebar_label:"Data Structs",description:"Learn what data structs are in Rust."},u=void 0,l={unversionedId:"Rust/section5/structs",id:"Rust/section5/structs",isDocsHomePage:!1,title:"Data Structs in rust",description:"Learn what data structs are in Rust.",source:"@site/docs/Rust/section5/structs.md",sourceDirName:"Rust/section5",slug:"/Rust/section5/structs",permalink:"/docs/Rust/section5/structs",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section5/structs.md",version:"current",lastUpdatedBy:"Bader Youssef",lastUpdatedAt:1680371977,formattedLastUpdatedAt:"4/1/2023",frontMatter:{id:"structs",title:"Data Structs in rust",sidebar_label:"Data Structs",description:"Learn what data structs are in Rust."},sidebar:"rust",previous:{title:"Collections - Vectors, Strings, Hashmaps",permalink:"/docs/Rust/section5/collections"},next:{title:"Defining Methods for Structs",permalink:"/docs/Rust/section5/struct-methods"}},c=[{value:"Creating Structs",id:"creating-structs",children:[{value:"Accessing Fields",id:"accessing-fields",children:[]},{value:"Shorthand Syntax",id:"shorthand-syntax",children:[]}]},{value:"Different types of Structs",id:"different-types-of-structs",children:[{value:"Updatable Structs",id:"updatable-structs",children:[]},{value:"Tuple &amp; Unit Structs",id:"tuple--unit-structs",children:[]}]},{value:"Ownerships in Structs",id:"ownerships-in-structs",children:[]},{value:"Try it yourself!",id:"try-it-yourself",children:[]},{value:"What&#39;s happening here?",id:"whats-happening-here",children:[]}],p={toc:c};function d(e){var t=e.components,n=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"A ",(0,s.kt)("strong",{parentName:"p"},"struct"),", sometimes called a ",(0,s.kt)("strong",{parentName:"p"},"data structure"),", is a collection of multiple types into a single data type.  It's similar to tuples in concept but provides several ways to expand and define custom struct behavior.  Structs, like any other type, abide by Rust's strict typing system and allow for a plethora of expansion when it comes to programming in Rust."),(0,s.kt)("h2",{id:"creating-structs"},"Creating Structs"),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"struct")," keyword is used to instantiate struct, followed by the name, then a series of fields between curly brackets.  Each field is akin to a key-value pair and must specify a type:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"struct Person {\n    age: i32,\n    name: String,\n}\n")),(0,s.kt)("p",null,"In this example, we declared a struct called ",(0,s.kt)("inlineCode",{parentName:"p"},"Person")," with two fields - a ",(0,s.kt)("inlineCode",{parentName:"p"},"name")," and an ",(0,s.kt)("inlineCode",{parentName:"p"},"age"),".  To use this struct, you must create an ",(0,s.kt)("strong",{parentName:"p"},"instance")," of it by setting it equal to some variable - pay attention to its syntax:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'let a_person = Person {\n    age: 22,\n    name: String::from("Bader"),\n};\n')),(0,s.kt)("p",null,"Notice that each field ",(0,s.kt)("em",{parentName:"p"},"must")," abide by the type set when the struct was defined initially.  Structs are instantiated by declaring the name (",(0,s.kt)("inlineCode",{parentName:"p"},"Person"),") followed by curly brackets, with the key-value representations of the fields specified (",(0,s.kt)("inlineCode",{parentName:"p"},"age: 22"),")."),(0,s.kt)("h3",{id:"accessing-fields"},"Accessing Fields"),(0,s.kt)("p",null,"Once we've created an instance of a struct, we can use the dot operator (",(0,s.kt)("inlineCode",{parentName:"p"},"."),") to access the values within: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'let a_person = Person {\n    age: 22,\n    name: String::from("Bader"),\n};\n\nprintln!("The age of the person is: {a_person.age}"); // 22\n')),(0,s.kt)("p",null,"Like any other variable in Rust, this one can also be declared mutable, making it possible to change the value of the struct's inner fields if desired."),(0,s.kt)("h3",{id:"shorthand-syntax"},"Shorthand Syntax"),(0,s.kt)("p",null,'It\'s rare to construct structs using this syntax.  Oftentimes, a function that acts as a "blueprint" is ideal: '),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// A function that asks for two parameters: an age, and name.\n// It returns a `Person` from this information.\nfn create_person(age: u32, name: String) -> Person {\n    // Notice we can use the expression as the last expression\n    // to return a new instance of `Person`\n    Person {\n        age: age,\n        name: name\n    }\n}\n\n// Now we can use the function instead!\n// It is of type 'Person', which is inferred without being explicitly defined.\nlet a_person: Person = create_person(22, String::from(\"Bader\"));\n")),(0,s.kt)("p",null,'It\'s also possible to have a "shorthand" way of representing struct fields if both the parameters and field names are the same, rather than using the ',(0,s.kt)("inlineCode",{parentName:"p"},"key: value")," format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// A function that asks for two parameters: an age and name.\n// It returns a `Person` from this information.\nfn create_person(age: u32, name: String) -> Person {\n    // Because both the parameters and struct fields are the same name, \n    // it's possible to write them shorthanded.\n    Person {\n        age,\n        name\n    }\n}\n")),(0,s.kt)("h2",{id:"different-types-of-structs"},"Different types of Structs"),(0,s.kt)("p",null,"Structs can take a couple of different forms syntactically.  All are valid structs and can utilize traits and methods, just with different syntax. "),(0,s.kt)("h3",{id:"updatable-structs"},"Updatable Structs"),(0,s.kt)("p",null,"If you've ever used Javascript, then you may be familiar with the spread operator: ",(0,s.kt)("inlineCode",{parentName:"p"},".."),".  In Rust, you can use this to create a new struct from an old one with values changed as needed: "),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},'// Instead of doing this:\nlet a_person = Person {\n    age: 22,\n    name: String::from("Bader"),\n};\n\nlet older_person_same_name = Person {\n    age: 23,\n    name: a_person.name,\n};\n\n// You can use `..` to make it more concise:\nlet a_person = Person {\n    age: 22,\n    name: String::from("Bader"),\n};\n\nlet older_person_same_name = Person {\n    age: 23,\n    // This operator now allowed for this instance of `Person`\n    // to inherit all attributes except age because we specified it.\n    ..a_person\n};\n')),(0,s.kt)("p",null,"The ",(0,s.kt)("inlineCode",{parentName:"p"},"..")," syntax will assume all other fields as the previous struct, except for the ones which you have specified explicitly."),(0,s.kt)("h3",{id:"tuple--unit-structs"},"Tuple & Unit Structs"),(0,s.kt)("p",null,"Structs may also be expressed in a tuple-like format:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// A struct that represents RGB color values.\nstruct RGB(u32, u32, u32);\nlet black = RGB(0, 0, 0);\n")),(0,s.kt)("p",null,"The difference between this and a tuple is that this is still a struct with a unique type - meaning it's possible to implement any traits or functionality."),(0,s.kt)("p",null,'The same logic applies to the "unit-type" struct, which is just a struct that contains no fields at all.  These are mostly used as a sort of marker to dictate what types the program should expect (and that doesn\'t require any sort of data): '),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-rust"},"// A struct that has no fields\nstruct AlwaysEqual;\n")),(0,s.kt)("h2",{id:"ownerships-in-structs"},"Ownerships in Structs"),(0,s.kt)("p",null,"If you observed, we used ",(0,s.kt)("inlineCode",{parentName:"p"},"String"),", an ownable data type, versus ",(0,s.kt)("inlineCode",{parentName:"p"},"&str")," in our struct.  This was for a reason - as we want the fields within to be owned for as long as the struct lives.  It is possible for structs to store references to data owned elsewhere, but only with the use of lifetimes - which will be discussed later."),(0,s.kt)("h2",{id:"try-it-yourself"},"Try it yourself!"),(0,s.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=%2F%2F+Defining+a+struct+that+represents+a+Person%0Astruct+Person+%7B%0A++++age%3A+u32%2C%0A++++name%3A+String%2C%0A%7D%0A%0A%2F%2F+Example+of+a+%22tuple-like%22+struct%0Astruct+RGB%28u32%2C+u32%2C+u32%29%3B%0A%0A%2F%2F+A+%22unit-type%22+struct%2C+which+has+no+fields%0Astruct+AlwaysEqual%3B%0A%0A%2F%2F+A+function+that+asks+for+two+parameters%3A+an+age%2C+and+name.%0A%2F%2F+It+returns+a+%60Person%60+from+this+information.%0Afn+create_person%28age%3A+u32%2C+name%3A+String%29+-%3E+Person+%7B%0A++++%2F%2F+Notice+we+can+use+the+expression+as+the+last+expression%0A++++%2F%2F+to+return+a+new+instance+of+%60Person%60%0A++++%2F%2F+Note+the+shorthand+syntax%21%0A++++Person+%7B%0A++++++++age%2C%0A++++++++name%0A++++%7D%0A%7D%0A%0Afn+main%28%29+%7B%0A++++%2F%2F+Defining+a+struct%2C+where+it+takes+%27age%27+as+an+i32+and+%27name%27+as+a+String%0A++++let+a_person+%3D+Person+%7B%0A++++++++age%3A+22%2C%0A++++++++name%3A+String%3A%3Afrom%28%22Bader%22%29%2C%0A++++%7D%3B%0A++++%0A++++%2F%2F+Using+the+dot+operator+to+access+the+%27age%27+field+of+the+struct%0A++++println%21%28%22The+age+of+the+person+is%3A+%7B%7D%22%2C+a_person.age%29%3B+%2F%2F+22%0A++++%0A++++let+other_bader%3A+Person+%3D+create_person%2825%2C+String%3A%3Afrom%28%22OtherBader%22%29%29%3B%0A++++%0A++++%2F%2F+Using+the+%27spread-like-operator%27+to+inherit+previous+struct+values%0A++++let+older_person_same_name+%3D+Person+%7B%0A++++age%3A+23%2C%0A++++%2F%2F+This+operator+now+allowed+for+this+instance+of+%60Person%60%0A++++%2F%2F+to+inherit+all+attributes+except+age%2C+because+we+specified+it.%0A++++..a_person%0A%7D%3B%0A++++%0A%7D%0A"}),(0,s.kt)("h2",{id:"whats-happening-here"},"What's happening here?"),(0,s.kt)("p",null,"A struct is defined with two fields, ",(0,s.kt)("inlineCode",{parentName:"p"},"age")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"name"),'.  Several instances are constructed, as well as an updated version which uses some of the previous values to create a new struct.  Several other concepts are also illustrated, such as the use of the "tuple" and "unit" like structs.'))}d.isMDXComponent=!0}}]);