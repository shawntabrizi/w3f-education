"use strict";(self.webpackChunkw3f_education=self.webpackChunkw3f_education||[]).push([[1760],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),m=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=m(e.components);return r.createElement(l.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=m(n),d=a,h=c["".concat(l,".").concat(d)]||c[d]||p[d]||i;return n?r.createElement(h,o(o({ref:t},u),{},{components:n})):r.createElement(h,o({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[c]="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=n[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9132:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(7462),a=(n(7294),n(3905));const i={id:"borrowing",title:"Borrowing & References in Rust",sidebar_label:"Borrowing & References",description:"Learn how the borrowing model works in Rust, and how to utilize it properly."},o=void 0,s={unversionedId:"Rust/section3/borrowing",id:"Rust/section3/borrowing",isDocsHomePage:!1,title:"Borrowing & References in Rust",description:"Learn how the borrowing model works in Rust, and how to utilize it properly.",source:"@site/docs/Rust/section3/borrowing.md",sourceDirName:"Rust/section3",slug:"/Rust/section3/borrowing",permalink:"/docs/Rust/section3/borrowing",editUrl:"https://github.com/w3f/w3f-education/edit/main/docs/Rust/section3/borrowing.md",version:"current",lastUpdatedBy:"Radha",lastUpdatedAt:1679968849,formattedLastUpdatedAt:"3/28/2023",frontMatter:{id:"borrowing",title:"Borrowing & References in Rust",sidebar_label:"Borrowing & References",description:"Learn how the borrowing model works in Rust, and how to utilize it properly."},sidebar:"rust",previous:{title:"The Ownership Model",permalink:"/docs/Rust/section3/ownership"},next:{title:"Slices",permalink:"/docs/Rust/section3/slices"}},l=[{value:"Problem: Heap-stored Values",id:"problem-heap-stored-values",children:[]},{value:"Borrowing &amp; Moving (Lack thereof)",id:"borrowing--moving-lack-thereof",children:[]},{value:"Mutable &amp; Immutable References",id:"mutable--immutable-references",children:[{value:"Mutable Reference Rules",id:"mutable-reference-rules",children:[]}]},{value:"Try it out!",id:"try-it-out",children:[]},{value:"What&#39;s happening here?",id:"whats-happening-here",children:[]}],m={toc:l},u="wrapper";function c(e){let{components:t,...n}=e;return(0,a.kt)(u,(0,r.Z)({},m,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The borrowing model in Rust is quite trivial.  As mentioned, ownership issues may arise when dealing with values stored on the heap (in other words, values that aren't of fixed size and are defined at compile time)."),(0,a.kt)("p",null,"While ownership does ensure that all memory will be allocated appropriately/deallocated, it does introduce some complexity that references and borrowing solve."),(0,a.kt)("h2",{id:"problem-heap-stored-values"},"Problem: Heap-stored Values"),(0,a.kt)("p",null,"Data types that aren't fixed size and have the potential to grow in size during runtime are stored on the ",(0,a.kt)("strong",{parentName:"p"},"heap"),".  Because the compiler can't tell what the value ",(0,a.kt)("em",{parentName:"p"},"could")," be at compile time, it's managed during the runtime.  "),(0,a.kt)("p",null,"The primary issue with this is when a potential ",(0,a.kt)("strong",{parentName:"p"},"move"),", or change in ownership, occurs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nfn main() {\n    // Create a String collection from a string literal (&str)\n    let name = String::from("Bader");\n    take_my_string(name);\n    // Error!\n    println!("{name}");\n}\n\nfn take_my_string(s: String) {\n    // Prints a reverse string\n    println!("{}", s.chars().rev().collect::<String>());\n}\n\n')),(0,a.kt)("p",null,"There is a problem with this code - that's that, in order to maintain memory safety and follow the rules of ownership, the variable",(0,a.kt)("inlineCode",{parentName:"p"},"name")," was moved to the ",(0,a.kt)("inlineCode",{parentName:"p"},"fn take_my_string")," function.  In other words, it owns it because it is stored on the heap.  "),(0,a.kt)("p",null,"Fixed-size variables are copied - as the compiler knows exactly ",(0,a.kt)("em",{parentName:"p"},"what")," to copy, whereas values on the heap are ",(0,a.kt)("em",{parentName:"p"},"moved"),".  Once moved, they cannot be used within that context."),(0,a.kt)("h2",{id:"borrowing--moving-lack-thereof"},"Borrowing & Moving (Lack thereof)"),(0,a.kt)("p",null,"The borrowing system in Rust solves this issue.  Using ",(0,a.kt)("strong",{parentName:"p"},"references"),", which are denoted by ",(0,a.kt)("inlineCode",{parentName:"p"},"&,")," we can avoid moving the String directly and instead just use a reference to it.  This references points to where it exists in memory, in contrast to moving it all together:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nfn main() {\n    // Create a String collection from a string literal (&str)\n    let name = String::from("Bader");\n    // We allow the function to borrow our String as a reference.\n    take_my_string(&name);\n    // No longer an error!  The main function is to maintain ownership.\n    println!("{name}");\n}\n\n// Now, instead of taking a String - we merely take a reference to it.\nfn take_my_string(s: &String) {\n    // Prints a reverse string\n    println!("{}", s.chars().rev().collect::<String>());\n}\n\n')),(0,a.kt)("p",null,"Using a reference to ",(0,a.kt)("inlineCode",{parentName:"p"},"name"),", we allow ",(0,a.kt)("inlineCode",{parentName:"p"},"take_my_string")," to ",(0,a.kt)("strong",{parentName:"p"},"borrow")," the value versus taking complete ownership.  We can perform whatever we want with it, but as soon as the function is complete, ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," returns back to main's ownership."),(0,a.kt)("h2",{id:"mutable--immutable-references"},"Mutable & Immutable References"),(0,a.kt)("p",null,"Mutable references are also possible - just be aware that like borrowing and references also have several rules:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Only one mutable reference is allowed at a time"),(0,a.kt)("li",{parentName:"ul"},"Any number of immutable references is allowed"),(0,a.kt)("li",{parentName:"ul"},"References must always be valid (no ",(0,a.kt)("em",{parentName:"li"},"dangling")," references: variables that return a reference that ends up getting dropped at the end of some scope).")),(0,a.kt)("p",null,"As an example, let's modify the value of a variable, then give ownership back via borrowing:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nfn main() {\n    // Create a String collection from a string literal (&str)\n    let mut name = String::from("Bader");\n    // We allow the function to borrow our String as a reference - but mutable\n    // Notice the `&mut` - this is necessary for any time we reference a mutable reference\n    take_my_string_and_change_it(&mut name);\n    // No longer an error!  The main function maintains ownership.\n    // But we also modified the value \ud83d\ude0e\n    println!("{name}");\n}\n\n// Now, instead of taking a String - we merely take a reference to it.\n// Again, we must use `&mut` to signal that we expect a mutable reference\nfn take_my_string_and_change_it(s: &mut String) {\n    s.push_str(" OOO");\n}\n\n')),(0,a.kt)("h3",{id:"mutable-reference-rules"},"Mutable Reference Rules"),(0,a.kt)("p",null,"The compiler looks for any instances where more than one mutable reference may exist at a time, but more than one immutable references are fine.  However, once an immutable reference is defined, no mutable reference can be made:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet mut name = String::from("Bader");\n\n// This is an immutable reference to a mutable variable\nlet ref_to_name = &name;\n// This is *another* immutable reference to a mutable variable\nlet ref_to_name_2 = &name;\n// And this is a mutable reference, denoted by `&mut`\nlet mut_ref_to_name = &mut name;\n\n')),(0,a.kt)("p",null,"This is primarily to avoid ",(0,a.kt)("em",{parentName:"p"},"data races")," - going back to Rust's memory safety; it prevents multiple pointers from attempting to modify the same value in the program."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nlet mut name = String::from("Bader");\n\n// And this is a mutable reference, denoted by `&mut`\nlet mut_ref_to_name = &mut name;\n// And this is ANOTHER mutable reference\nlet mut_ref_to_name_2 = &mut name;\n\nprintln!("{mut_ref_to_name}, {mut_ref_to_name_2}");\n\n')),(0,a.kt)("p",null,"This won't compile, as the compiler will recognize that we have two potentially modifiable references to the same variable."),(0,a.kt)("h2",{id:"try-it-out"},"Try it out!"),(0,a.kt)("iframe",{width:"100%",height:"580",src:"https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&code=fn+main%28%29+%7B%0A++++%2F%2F+Create+a+String+collection+from+a+string+literal+%28%26str%29%0A++++let+mut+name+%3D+String%3A%3Afrom%28%22Bader%22%29%3B%0A++++%2F%2F+We+allow+the+function+to+borrow+our+String+as+a+reference+-+but+mutable%0A++++%2F%2F+Notice+the+%60%26mut%60+-+this+is+necessary+for+any+time+we+reference+a+mutable+reference%0A++++println%21%28%22Before%3A+%7Bname%7D%22%29%3B%0A++++take_my_string_and_change_it%28%26mut+name%29%3B%0A++++%2F%2F+No+longer+an+error%21+The+main+function+maintains+ownership.%0A++++%2F%2F+But+we+also+modifed+the+value+%F0%9F%98%8E%0A++++println%21%28%22After%3A+%7Bname%7D%22%29%3B%0A%7D%0A%0A%2F%2F+Now%2C+instead+of+taking+a+String+-+we+merely+take+a+reference+to+it.%0A%2F%2F+Again%2C+we+must+use+%60%26mut%60+to+signal+that+we+expect+a+mutable+reference%0Afn+take_my_string_and_change_it%28s%3A+%26mut+String%29+%7B%0A++++s.push_str%28%22+OOO%22%29%3B%0A%7D"}),(0,a.kt)("h2",{id:"whats-happening-here"},"What's happening here?"),(0,a.kt)("p",null,"This example shows cases of a mutable variable being borrowed by a function, modified, then returned to the scope of ",(0,a.kt)("inlineCode",{parentName:"p"},"main"),".  Notice we can still use the variable, even after it has been passed to the function."))}c.isMDXComponent=!0}}]);